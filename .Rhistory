names(est_sim_lc) <- rep("est_sim", n_classes)
est_sim_lc <- map(est_sim_lc, function(x){ x %>%
select(-class)})
sim_welfare <- map(est_sim_lc, PrepareSimulationData, stan_est, policies, nsims)
}
df_common <- sim_welfare
df_common <- map(df_common, function(x){x$df_indiv <- NULL})
df_common <- sim_welfare
df_common <- map(df_common, function(x){x[-df_indiv]})
View(df_common)
df_common <- map(df_common, `[`, c("price_p_list", "gamma_sim_list", "alpha_sim_list", "scale_sim"))
df_common <- sim_welfare
df_common <- map(df_common, `[`, -c("df_indiv"))
df_common <- sim_welfare
df_common <- map(df_common, extract, -c("df_indiv"))
df_common <- map(df_common, extract, c("df_indiv"))
df_common <- map(df_common, -`[`, c("df_indiv"))
df_common <- map(df_common, `-[`, c("df_indiv"))
df_common <- map(df_common, `[`, c("price_p_list", "gamma_sim_list", "alpha_sim_list", "scale_sim"))
df_common <- map(sim_welfare, `[`, c("price_p_list", "gamma_sim_list", "alpha_sim_list", "scale_sim"))
df_indiv <- map(sim_welfare, `[`, c("df_indiv"))
View(df_indiv)
names(df_common) <- rep("df_common", n_classes)
View(df_common)
View(df_common)
df_indiv <- map(sim_welfare, `[`, c("df_indiv"))
df_indiv <- flatten_int(map(sim_welfare, `[`, c("df_indiv")), 1)
df_indiv <- flatten_int(map(sim_welfare, `[`, c("df_indiv")))
df_indiv <- flatten(map(sim_welfare, `[`, c("df_indiv")))
View(df_indiv)
View(df_indiv)
wtp <- map2(df_common, df_indiv, StanWTP, sim_options)#, parralel)
View(df_indiv)
View(df_common)
?map2
StanWTP <- function(df_indiv, df_common, sim_options){#, parralel){
wtpcppcode <- stanc("src/stan_files/SimulationFunctions.stan",
model_name = "SimulationFunctions")
#	if (parralel == FALSE){
expose_stan_functions(wtpcppcode)
wtp <- pmap(df_indiv, CalcWTP_rng,
price_p=df_common$price_p_list,
gamma_sim=df_common$gamma_sim_list,
alpha_sim=df_common$alpha_sim_list,
scale_sim=df_common$scale_sim,
nerrs=sim_options$nerrs,
cond_error=sim_options$cond_error,
algo_gen=sim_options$algo_gen,
model_num=sim_options$model_num)#,
#	} else if (parralel == TRUE){
#		wtp <- future_pmap(df_indiv, SimulateWTPParallel,
#						   price_p=df_common$price_p_list,
#						   gamma_sim=df_common$gamma_sim_list,
#						   alpha_sim=df_common$alpha_sim_list,
#						   scale_sim=df_common$scale_sim,
#						   nerrs=sim_options$nerrs,
#						   cond_error=sim_options$cond_error,
#						   algo_gen=sim_options$algo_gen,
#						   model_num=sim_options$model_num,
#						   wtpcppcode = wtpcppcode,
#						   .progress = TRUE,
#						   .options = future_options(packages=c("rstan"), globals = FALSE))
#	}
return(wtp)
}
wtp <- map2(df_common, df_indiv, StanWTP, sim_options)#, parralel)
est_sim_lc <- est_sim %>%
filter(!str_detect(parms, "beta")) %>%
separate(parms, into = c("parms", "class", "good")) %>%
mutate(good = ifelse(is.na(as.numeric(good)), "0", good )) %>%
unite(parms, parms, good)
est_sim_lc <- split( est_sim_lc , f = est_sim_lc$class )
names(est_sim_lc) <- rep("est_sim", n_classes)
est_sim_lc <- map(est_sim_lc, function(x){ x %>%
select(-class)})
sim_welfare <- map(est_sim_lc, PrepareSimulationData, stan_est, policies, nsims)
df_common <- map(sim_welfare, `[`, c("price_p_list", "gamma_sim_list", "alpha_sim_list", "scale_sim"))
names(df_common) <- rep("df_common", n_classes)
df_indiv <- flatten(map(sim_welfare, `[`, c("df_indiv")))
sim_options <- list(nerrs = nerrs,
cond_error = cond_error,
algo_gen = algo_gen,
model_num = model_num)
nerrs = 30
nsims = 30
cond_error = 1
algo_gen = NULL
sim_options <- list(nerrs = nerrs,
cond_error = cond_error,
algo_gen = algo_gen,
model_num = model_num)
wtp <- map2(df_common, df_indiv, StanWTP, sim_options)#, parralel)
wtp <- map2(df_common, df_indiv, StanWTP, sim_options)#, parralel)
wtp <- map2(df_common, df_indiv, StanWTP, sim_options)#, parralel)
wtp <- map2(df_common, df_indiv, StanWTP)#, parralel)
View(df_indiv)
df_indiv <- 		map(sim_welfare, `[`, c("df_indiv"))
wtp <- map2(df_common, df_indiv, StanWTP, sim_options)#, parralel)
df_indiv <- flatten(map(sim_welfare, `[`, c("df_indiv")))
wtp <- map2(df_indiv, df_common, StanWTP, sim_options)#, parralel)
df_indiv <- df_indiv$df_indiv
df_common <- df_common$df_common
wtpcppcode <- stanc("src/stan_files/SimulationFunctions.stan",
model_name = "SimulationFunctions")
#	if (parralel == FALSE){
expose_stan_functions(wtpcppcode)
wtp <- pmap(df_indiv, CalcWTP_rng,
price_p=df_common$price_p_list,
gamma_sim=df_common$gamma_sim_list,
alpha_sim=df_common$alpha_sim_list,
scale_sim=df_common$scale_sim,
nerrs=sim_options$nerrs,
cond_error=sim_options$cond_error,
algo_gen=sim_options$algo_gen,
model_num=sim_options$model_num)
View(df_indiv)
View(df_indiv)
if (!is.null(algo_gen))
if (model_num < 3 && algo_gen == 0){
warning("Can't use hybrid algorithm with model_num = 1 or 2. Changing to general approach.")
algo_gen <- 1
}
if (is.null(algo_gen)) {# ensure
if (model_num == 3 || model_num == 4)
algo_gen <- 0
else if (model_num == 1 || model_num == 2)
algo_gen <- 1
}
if (nsims > stan_est$n_draws) {# ensure
nsims <- stan_est$n_draws
warning("Number of simulations > Number of Draws from stan_est. nsims has been set to: ", nsims)
}
sim_options <- list(nerrs = nerrs,
cond_error = cond_error,
algo_gen = algo_gen,
model_num = model_num)
wtp <- pmap(df_indiv, CalcWTP_rng,
price_p=df_common$price_p_list,
gamma_sim=df_common$gamma_sim_list,
alpha_sim=df_common$alpha_sim_list,
scale_sim=df_common$scale_sim,
nerrs=sim_options$nerrs,
cond_error=sim_options$cond_error,
algo_gen=sim_options$algo_gen,
model_num=sim_options$model_num)
StanWTP <- function(df_indiv, df_common, sim_options){#, parralel){
#	df_indiv <- df_indiv$df_indiv
#	df_common <- df_common$df_common
wtpcppcode <- stanc("src/stan_files/SimulationFunctions.stan",
model_name = "SimulationFunctions")
#	if (parralel == FALSE){
expose_stan_functions(wtpcppcode)
wtp <- pmap(df_indiv, CalcWTP_rng,
price_p=df_common$price_p_list,
gamma_sim=df_common$gamma_sim_list,
alpha_sim=df_common$alpha_sim_list,
scale_sim=df_common$scale_sim,
nerrs=sim_options$nerrs,
cond_error=sim_options$cond_error,
algo_gen=sim_options$algo_gen,
model_num=sim_options$model_num)
#	} else if (parralel == TRUE){
#		wtp <- future_pmap(df_indiv, SimulateWTPParallel,
#						   price_p=df_common$price_p_list,
#						   gamma_sim=df_common$gamma_sim_list,
#						   alpha_sim=df_common$alpha_sim_list,
#						   scale_sim=df_common$scale_sim,
#						   nerrs=sim_options$nerrs,
#						   cond_error=sim_options$cond_error,
#						   algo_gen=sim_options$algo_gen,
#						   model_num=sim_options$model_num,
#						   wtpcppcode = wtpcppcode,
#						   .progress = TRUE,
#						   .options = future_options(packages=c("rstan"), globals = FALSE))
#	}
return(wtp)
}
est_sim_lc <- est_sim %>%
filter(!str_detect(parms, "beta")) %>%
separate(parms, into = c("parms", "class", "good")) %>%
mutate(good = ifelse(is.na(as.numeric(good)), "0", good )) %>%
unite(parms, parms, good)
est_sim_lc <- split( est_sim_lc , f = est_sim_lc$class )
names(est_sim_lc) <- rep("est_sim", n_classes)
est_sim_lc <- map(est_sim_lc, function(x){ x %>%
select(-class)})
sim_welfare <- map(est_sim_lc, PrepareSimulationData, stan_est, policies, nsims)
df_common <- map(sim_welfare, `[`, c("price_p_list", "gamma_sim_list", "alpha_sim_list", "scale_sim"))
names(df_common) <- rep("df_common", n_classes)
df_indiv <- flatten(map(sim_welfare, `[`, c("df_indiv")))
wtp <- map2(df_indiv, df_common, StanWTP, sim_options)#, parralel)
View(wtp)
names(wtp) <- paste0("class", c(1:model_options$n_classes))
names(wtp) <- paste0("class", c(1:stan_est$n_classes))
View(wtp)
View(wtp)
# MDCEV Model with fixed parameters estimated using MLE or Stan
# Notes:
# Includes LES, Gamma, and Alpha specifications as options
# One set of psi parameters for individual and alternative-specific variables and interactions
# Load Packages ------------------------------------#
rm(list=ls(all=TRUE))
ls()
library(pacman)
p_load(tidyverse, R.matlab, reshape2, rstan, rmdcev)
#source("r/helperFunctions.R")
#---------------------------------------------------------------------------------------
# user input
nobs <- 1000 # number of individuals
inc <- 100000 + runif(nobs, 0, 50000) # budget
ngoods <- 10 # number of goods
price <- 5 + matrix(runif(nobs*ngoods, 0, 100), nobs, ngoods)  # price of non-numeraire good
price_num <- 1
nerrs <- 1
weight <- 1 #Modify if weights are used
nsims <- 1
algo_gen <- 0
model <- "gamma"
beta <- c(-7, 0.5, 2, -1.5, 3, -2, 1, 2)
gamma <- 1 + runif(ngoods, 0, 2)
scale <- 1
fixed_scale <- 0
#---------------------------------------------------------------------------------------
if (model == "alpha"){
model_num <- 1
alpha <- c(0.8, rep(0, ngoods))
parms_true <- c(beta, gamma, alpha[1], scale)
} else if (model == "alpha"){
model_num <- 2
alpha <- 0 + runif(ngoods+1, 0.01, .98)
gamma <- rep(1, ngoods)
parms_true <- c(beta, alpha, scale)
} else if (model == "gamma"){
model_num <- 3
alpha <- rep(0.5, ngoods+1)
parms_true <- c(beta, gamma, alpha[1], scale)
} else if (model == "gamma0"){
model_num <- 4
alpha <- rep(0, ngoods+1)
parms_true <- c(beta, gamma, scale)
} else
stop("No model specificied. Choose a model")
parms_true <- tbl_df(parms_true) %>%
rename(parms_true = value)
# Create psi variables that vary over alternatives
b1 <- rep(1,ngoods)
b2 <- rbinom(ngoods, 1, 0.5)
b3 <- rbinom(ngoods, 1, 0.5)
psi_j_temp <- list(b1 = b1,
b2 = b2,
b3 = b3)
# Create psi variables that vary by person
psi_socio = 2*matrix(runif(nobs * (length(beta)-3)), nobs,length(beta)-3)
psi_i_temp <- list(b4 = psi_socio[,1],
b5 = psi_socio[,2],
b5 = psi_socio[,3],
b5 = psi_socio[,4],
b5 = psi_socio[,5])
# Create full set of base psi variables
psi_j_temp <- map(psi_j_temp, function(x) {rep(x, each=nobs)})
psi_i_temp <- map(psi_i_temp, function(x) {rep(x, times= ngoods)})
dat_psi = c(psi_j_temp, psi_i_temp)
dat_psi = matrix(unlist(dat_psi), ncol = length(beta))
psi_sims <- matrix(dat_psi %*% beta, ncol = ngoods, byrow = TRUE)
psi_sims <- CreateListsRow(psi_sims)
psi_sims <- list(psi_sims )
names(psi_sims) <- "psi_sims"
inc_list <- list(as.list(inc))
names(inc_list) <- "inc" # price normalized MU at zero
price_list <- cbind(1, price) #add numeraire price to price matrix (<-1)
price_list <- list(CreateListsRow(price_list))
names(price_list) <- "price" # price normalized MU at zero
###########################################################################
# Pull individual level data into one list
###########################################################################
df_temp <- c(inc_list, price_list, psi_sims)
# choose number of people to simulate (set to nobs for all)
nobs_sims <- nobs
df_subset <- lapply(df_temp, "[", c(1:nobs_sims))
# To try and get expose as part of package
#options(rccp.cpp.dir="cache")
#model_src <- stanc_builder("src/stan_files/SimulationFunctions.stan")
#expose_stan_functions(model_src, cacheDir = "cache")
wtpcppcode <- stanc("src/stan_files/SimulationFunctions.stan",
model_name = "SimulationFunctions")
start_time <- Sys.time()
expose_stan_functions(wtpcppcode)
quant <- pmap(df_subset, Calcmdemand_rng,
gamma_sim=gamma,
alpha_sim=alpha,
scale_sim=scale,
nerrs=nerrs,algo_gen = algo_gen)
end_time <- Sys.time()
end_time - start_time
# Convert simulated data into estimation data
quant <- matrix(unlist(quant), nrow = nobs, byrow = TRUE)
dat_psi_list <- lapply(seq_len(ncol(dat_psi)), function(i) dat_psi[,i])
quant <- quant[,2:(ncol(quant))]
stan.dat <- list(quant = quant,
price = price,
inc = as.vector(inc),
dat_psi = dat_psi_list)
weights <-  rep(1, length(inc))
summary(quant)
# default is one
n_classes = 2
hessian = TRUE
algorithm = "MLE"
price_num = NULL
fixed_scale = 0
trunc_data = 0
keep_loglik = 0
print_ll = 1
n_draws = 5
n_chains = 4
n_cores = 4
n_iterations = 500
#data_class <- as.array(rep(1, nobs), dim = 1)
#source('T:/Code/rmdcev/R/FitMDCEV.R')
#source('T:/Code/rmdcev/R/processMDCEVdata.R')
#source('T:/Code/rmdcev/R/maxLikeMDCEV.R')
#source('T:/Code/rmdcev/R/HierarchicalBayesMDCEV.R')
# initial starting values
initial.parameters <- list(psi = rep(0,ncol(dat_psi)),
scale = as.array(1, dim = 1),
alpha = as.array(0.5, dim = 1),
gamma = rep(1,ncol(quant)))
#devtools::install(local=TRUE)
stan_est <- FitMDCEV(stan.dat,
#		   data_class = data_class,
weights = weights,
#				   price_num = NULL,
model = model,
n_classes = n_classes,
fixed_scale = fixed_scale,
trunc_data = trunc_data,
seed = 123,
#				   n_iterations = n_iterations, n_chains = n_chains,
algorithm = algorithm,
#	std_errors = "draws", # still need to implement
print_ll = 0,
#mle_tol = 0.0001,
hessian = TRUE,
#	   initial.parameters = initial.parameters,
n_draws = 30,
keep_loglik = 0)
stan_est$est_pars <- tbl_df(stan_est[["stan_fit"]][["theta_tilde"]]) %>%
select(-starts_with("log_like"), -starts_with("sum_log_lik")) %>%
rowid_to_column("sim_id") %>%
gather(parms, value, -sim_id, factor_key=TRUE)
save(stan_est, file = "C:/Dropbox/Research/code/mdcev_sim.RData")
rm(list=ls(all=TRUE))
ls()
# Load Packages ------------------------------------#
#library(pacman)
library(pacman)
p_load(tidyverse, R.matlab, reshape2, rstan, rmdcev)
# Import Data ------------------------------------#
load("C:/Dropbox/Research/code/mdcev_sim.RData")
# Set functions ------------------------------------#
source("r/helperFunctions.R")
source("r/PrepareSimulationData.R")
source("r/CreateSimulationData.R")
source("r/SimulateWTP.R")
###########################################################################
# Create policy scenarios (can affect price only at this point)
###########################################################################
npols <- 2
policies<-	CreateBlankPolicies(npols, stan_est$stan_data[["J"]], stan_est$stan_data[["dat_psi"]])
# Closing each site individual than all together
#price_p <- cbind(0,diag(stan_est$stan_data[["J"]])*10000000)
#policies$price_p <- CreateListsRow(price_p)
#price_p <- rbind(price_p, c(0,rep(100000000,ngoods)))# add all closures to price_list
#price_p <- rbind(c(0,100000000,rep(100000000,ngoods-1)), c(0,rep(100000000,ngoods)))# add all closures to price_list
wtp <- SimulateWTP(stan_est, policies, algo_gen = 1, nsims = 3, nerrs = 3)
source('C:/Dropbox/Research/code/EstimateMDCEVSimulated.R')
rm(list=ls(all=TRUE))
ls()
# Load Packages ------------------------------------#
#library(pacman)
library(pacman)
p_load(tidyverse, R.matlab, reshape2, rstan, rmdcev)
# Import Data ------------------------------------#
load("C:/Dropbox/Research/code/mdcev_sim.RData")
# Set functions ------------------------------------#
source("r/helperFunctions.R")
source("r/PrepareSimulationData.R")
source("r/CreateSimulationData.R")
source("r/SimulateWTP.R")
###########################################################################
# Create policy scenarios (can affect price only at this point)
###########################################################################
npols <- 2
policies<-	CreateBlankPolicies(npols, stan_est$stan_data[["J"]], stan_est$stan_data[["dat_psi"]])
# Closing each site individual than all together
#price_p <- cbind(0,diag(stan_est$stan_data[["J"]])*10000000)
#policies$price_p <- CreateListsRow(price_p)
#price_p <- rbind(price_p, c(0,rep(100000000,ngoods)))# add all closures to price_list
#price_p <- rbind(c(0,100000000,rep(100000000,ngoods-1)), c(0,rep(100000000,ngoods)))# add all closures to price_list
wtp <- SimulateWTP(stan_est, policies, algo_gen = 1, nsims = 3, nerrs = 3)
est_sim_lc <- est_sim %>%
filter(!str_detect(parms, "beta")) %>%
separate(parms, into = c("parms", "class", "good")) %>%
mutate(good = ifelse(is.na(as.numeric(good)), "0", good )) %>%
unite(parms, parms, good)
est_pars <- tbl_df(stan_est[["stan_fit"]][["theta_tilde"]]) %>%
select(-starts_with("log_like"), -starts_with("sum_log_lik")) %>%
rowid_to_column("sim_id") %>%
gather(parms, value, -sim_id, factor_key=TRUE)
# Sample from parameter estimate draws
est_sim <- est_pars %>%
distinct(sim_id) %>%
sample_n(., nsims ) %>%
left_join(est_pars, by = "sim_id")
nsims = 30
est_pars <- tbl_df(stan_est[["stan_fit"]][["theta_tilde"]]) %>%
select(-starts_with("log_like"), -starts_with("sum_log_lik")) %>%
rowid_to_column("sim_id") %>%
gather(parms, value, -sim_id, factor_key=TRUE)
# Sample from parameter estimate draws
est_sim <- est_pars %>%
distinct(sim_id) %>%
sample_n(., nsims ) %>%
left_join(est_pars, by = "sim_id")
est_sim_lc <- est_sim %>%
filter(!str_detect(parms, "beta")) %>%
separate(parms, into = c("parms", "class", "good")) %>%
mutate(good = ifelse(is.na(as.numeric(good)), "0", good )) %>%
unite(parms, parms, good)
est_sim_lc <- split( est_sim_lc , f = est_sim_lc$class )
names(est_sim_lc) <- rep("est_sim", stan_est$n_classes)
est_sim_lc <- map(est_sim_lc, function(x){ x %>%
select(-class)})
sim_welfare <- map(est_sim_lc, PrepareSimulationData, stan_est, policies, nsims)
df_common <- map(sim_welfare, `[`, c("price_p_list", "gamma_sim_list", "alpha_sim_list", "scale_sim"))
names(df_common) <- rep("df_common", stan_est$n_classes)
df_indiv <- flatten(map(sim_welfare, `[`, c("df_indiv")))
wtp <- map2(df_indiv, df_common, StanWTP, sim_options)#, parralel)
names(wtp) <- paste0("class", c(1:stan_est$n_classes))
rm(list=ls(all=TRUE))
ls()
# Load Packages ------------------------------------#
#library(pacman)
library(pacman)
p_load(tidyverse, R.matlab, reshape2, rstan, rmdcev)
# Import Data ------------------------------------#
load("C:/Dropbox/Research/code/mdcev_sim.RData")
# Set functions ------------------------------------#
source("r/helperFunctions.R")
source("r/PrepareSimulationData.R")
source("r/CreateSimulationData.R")
source("r/SimulateWTP.R")
###########################################################################
# Create policy scenarios (can affect price only at this point)
###########################################################################
npols <- 2
policies<-	CreateBlankPolicies(npols, stan_est$stan_data[["J"]], stan_est$stan_data[["dat_psi"]])
# Closing each site individual than all together
#price_p <- cbind(0,diag(stan_est$stan_data[["J"]])*10000000)
#policies$price_p <- CreateListsRow(price_p)
#price_p <- rbind(price_p, c(0,rep(100000000,ngoods)))# add all closures to price_list
#price_p <- rbind(c(0,100000000,rep(100000000,ngoods-1)), c(0,rep(100000000,ngoods)))# add all closures to price_list
wtp <- SimulateWTP(stan_est, policies, algo_gen = 1, nsims = 3, nerrs = 3)
?SimulateWTP
rm(list=ls(all=TRUE))
ls()
# Load Packages ------------------------------------#
#library(pacman)
library(pacman)
p_load(tidyverse, R.matlab, reshape2, rstan, rmdcev)
# Import Data ------------------------------------#
load("C:/Dropbox/Research/code/mdcev_sim.RData")
# Set functions ------------------------------------#
source("r/helperFunctions.R")
source("r/PrepareSimulationData.R")
source("r/CreateSimulationData.R")
source("r/SimulateWTP.R")
###########################################################################
# Create policy scenarios (can affect price only at this point)
###########################################################################
npols <- 2
policies<-	CreateBlankPolicies(npols, stan_est$stan_data[["J"]], stan_est$stan_data[["dat_psi"]])
# Closing each site individual than all together
#price_p <- cbind(0,diag(stan_est$stan_data[["J"]])*10000000)
#policies$price_p <- CreateListsRow(price_p)
#price_p <- rbind(price_p, c(0,rep(100000000,ngoods)))# add all closures to price_list
#price_p <- rbind(c(0,100000000,rep(100000000,ngoods-1)), c(0,rep(100000000,ngoods)))# add all closures to price_list
wtp <- SimulateWTP(stan_est, policies, algo_gen = 0, nsims = 3, nerrs = 3)
rm(list=ls(all=TRUE))
ls()
# Load Packages ------------------------------------#
#library(pacman)
library(pacman)
p_load(tidyverse, R.matlab, reshape2, rstan, rmdcev)
# Import Data ------------------------------------#
load("C:/Dropbox/Research/code/mdcev_sim.RData")
# Set functions ------------------------------------#
source("r/helperFunctions.R")
source("r/PrepareSimulationData.R")
source("r/CreateSimulationData.R")
source("r/SimulateWTP.R")
###########################################################################
# Create policy scenarios (can affect price only at this point)
###########################################################################
npols <- 2
policies<-	CreateBlankPolicies(npols, stan_est$stan_data[["J"]], stan_est$stan_data[["dat_psi"]])
# Closing each site individual than all together
#price_p <- cbind(0,diag(stan_est$stan_data[["J"]])*10000000)
#policies$price_p <- CreateListsRow(price_p)
#price_p <- rbind(price_p, c(0,rep(100000000,ngoods)))# add all closures to price_list
#price_p <- rbind(c(0,100000000,rep(100000000,ngoods-1)), c(0,rep(100000000,ngoods)))# add all closures to price_list
wtp <- SimulateWTP(stan_est, policies, algo_gen = 0, nsims = 3, nerrs = 3)
