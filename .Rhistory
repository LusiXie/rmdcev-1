hquant_test <- pmap(df_subset, CalchdemandTest_rng,
gamma_sim=gamma,
alpha_sim=alpha,
price_p = price_p,
scale_sim=scale,
ngoods=ngoods, nerrs=nerrs, nsims=nsims,npols = 1,
cond_error = 1,
algo_gen = algo_gen,
model_type = model_type)
end_time <- Sys.time()
end_time - start_time
source("r/helperFunctions.R")
# MDCEV Model with fixed parameters estimated using MLE or Stan
# Notes:
# Includes LES, Gamma, and Alpha specifications as options
# One set of psi parameters for individual and alternative-specific variables and interactions
# Load Packages ------------------------------------#
rm(list=ls(all=TRUE))
ls()
library(pacman)
p_load(tidyverse, R.matlab, reshape2, rstan, rmdcev)
source("r/helperFunctions.R")
#---------------------------------------------------------------------------------------
nobs <- 1000 # number of individuals
inc <- 100000 + runif(nobs, 0, 50000) # budget
ngoods <- 10 # number of goods
price <- 5 + matrix(runif(nobs*ngoods, 0, 100), nobs, ngoods)  # price of non-numeraire good
price_num <- 1
nerrs <- 1
weight    <- 1 #Modify if weights are used
nsims <- 1
algo_gen <- 1
model_specification <- "alpha"
beta <- c(-7, 0.5, 2, -1.5, 3, -2, 1, 2)
gamma <- 1 + runif(ngoods, 0, 2)
scale <- 1
fixed_scale <- 0
if (model_specification == "les"){
model_type <- 1
alpha <- c(0.8, rep(0, ngoods))
parms_true <- c(beta, gamma, alpha[1], scale)
} else if (model_specification == "alpha"){
model_type <- 2
alpha <- 0 + runif(ngoods+1, 0.01, .98)
gamma <- rep(1, ngoods)
parms_true <- c(beta, alpha, scale)
} else if (model_specification == "gamma"){
model_type <- 3
alpha <- rep(0.5, ngoods+1)
parms_true <- c(beta, gamma, alpha[1], scale)
} else if (model_specification == "gamma0"){
model_type <- 4
alpha <- rep(0, ngoods+1)
parms_true <- c(beta, gamma, scale)
} else
stop("No model specificied. Choose a model_specification")
parms_true <- tbl_df(parms_true) %>%
rename(parms_true = value)
# Create psi variables that vary over alternatives
b1 <- rep(1,ngoods)
b2 <- c(rep(1,ngoods/2), rep(0, ngoods / 2))
b3 <- rep(c(0,1), ngoods / 2)
psi_j_temp <- list(b1 = b1,
b2 = b2,
b3 = b3)
# Create psi variables that vary by person
psi_socio = 2*matrix(runif(nobs * (length(beta)-3)), nobs,length(beta)-3)
psi_i_temp <- list(b4 = psi_socio[,1],
b5 = psi_socio[,2],
b5 = psi_socio[,3],
b5 = psi_socio[,4],
b5 = psi_socio[,5])
# Create full set of base psi variables
psi_j_temp <- map(psi_j_temp, function(x) {rep(x, each=nobs)})
psi_i_temp <- map(psi_i_temp, function(x) {rep(x, times= ngoods)})
dat_psi = c(psi_j_temp, psi_i_temp)
dat_psi = matrix(unlist(dat_psi), ncol = length(beta))
psi_sims <- matrix(dat_psi %*% beta, ncol = ngoods, byrow = TRUE)
psi_sims <- CreateListsRow(psi_sims)
psi_sims <- list(psi_sims )
names(psi_sims) <- "psi_sims"
inc_list <- list(as.list(inc))
names(inc_list) <- "inc" # price normalized MU at zero
price_list <- cbind(1, price) #add numeraire price to price matrix (<-1)
price_list <- list(CreateListsRow(price_list))
names(price_list) <- "price" # price normalized MU at zero
###########################################################################
# Pull individual level data into one list
###########################################################################
df_temp <- c(inc_list, price_list, psi_sims)
# choose number of people to simulate (set to nobs for all)
nobs_sims <- nobs
df_subset <- lapply(df_temp, "[", c(1:nobs_sims))
# To try and get expose as part of package
#options(rccp.cpp.dir="cache")
#model_src <- stanc_builder("src/stan_files/SimulationFunctions.stan")
#expose_stan_functions(model_src, cacheDir = "cache")
#Rcpp::compileAttributes()
wtpcppcode <- stanc("src/stan_files/SimulationFunctions.stan",
model_name = "SimulationFunctions")
start_time <- Sys.time()
expose_stan_functions(wtpcppcode)
quant <- pmap(df_subset, Calcmdemand_rng,
gamma_sim=gamma,
alpha_sim=alpha,
scale_sim=scale,
ngoods=ngoods, nerrs=nerrs, nsims=nsims,
algo_gen = algo_gen)
end_time <- Sys.time()
end_time - start_time
psi_p_sims <- psi_sims
names(psi_p_sims) <- "psi_p_sims" # price normalized MU at zero
price_list <- cbind(1, price) #add numeraire price to price matrix (<-1)
price_list <- list(CreateListsRow(price_list))
names(price_list) <- "price" # price normalized MU at zero
price_p <- c(0,rep(10,ngoods))
price_p <- c(0,rep(0,ngoods))
quant_list <- list(map(quant, function(x){x[,2:(ngoods+1)]}))
names(quant_list) <- "quant_j" # price normalized MU at zero
df_temp <- c(inc_list, quant_list, price_list, psi_sims, psi_p_sims)
df_subset <- lapply(df_temp, "[", c(1:nobs_sims))
hquant_test <- pmap(df_subset, CalchdemandTest_rng,
gamma_sim=gamma,
alpha_sim=alpha,
price_p = price_p,
scale_sim=scale,
ngoods=ngoods, nerrs=nerrs, nsims=nsims,npols = 1,
cond_error = 1,
algo_gen = algo_gen,
model_type = model_type)
end_time <- Sys.time()
end_time - start_time
quant_h <- pmap(df_subset, CalchdemandTest_rng,
gamma_sim=gamma,
alpha_sim=alpha,
price_p = price_p,
scale_sim=scale,
ngoods=ngoods, nerrs=nerrs, nsims=nsims,npols = 1,
cond_error = 1,
algo_gen = algo_gen,
model_type = model_type)
end_time <- Sys.time()
end_time - start_time
test <- matrix(unlist(quant), nrow = nobs, byrow = TRUE) - matrix(unlist(quant_h), nrow = nobs, byrow = TRUE)
sum(test)
start_time <- Sys.time()
quant_h <- pmap(df_subset, CalchdemandTest_rng,
gamma_sim=gamma,
alpha_sim=alpha,
price_p = price_p,
scale_sim=scale,
ngoods=ngoods, nerrs=nerrs, nsims=nsims,npols = 1,
cond_error = 1,
algo_gen = algo_gen,
model_type = model_type)
end_time <- Sys.time()
end_time - start_time
test <- matrix(unlist(quant), nrow = nobs, byrow = TRUE) - matrix(unlist(quant_h), nrow = nobs, byrow = TRUE)
sum(test)
?source_test_helpers
Sys.setenv("R_TESTS" = "")
?sourceCpp
sourceCpp("C:/Dropbox/Research/code/rmdcev/src/stan_files/SimulationFunctions.hpp")
sourceCpp("C:/Dropbox/Research/code/rmdcev/src/stan_files/SimulationFunctions.cc")
sourceCpp("C:/Dropbox/Research/code/rmdcev/src/stan_files/SimulationFunctions.o")
sourceCpp("C:/Dropbox/Research/code/rmdcev/src/stan_files/SimulationFunctions.cc")
wtpcppcode <- stanc("C:/Dropbox/Research/code/rmdcev/src/stan_files/SimulationFunctions.stan",
model_name = "SimulationFunctions")
expose_stan_functions(wtpcppcode)
wtpcppcode <- stanc("C:/Dropbox/Research/code/rmdcev/src/stan_files/SimulationFunctions.stan",
model_name = "SimulationFunctions")
View(wtpcppcode)
wtpcppcode[["cppcode"]]
tt <- wtpcppcode$cppcode
fileConn<-file("output.txt")
writeLines(tt, fileConn)
close(fileConn)
fileConn<-file("src/stan_files/output.cpp")
writeLines(tt, fileConn)
close(fileConn)
sourceCpl("src/stan_files/output.cpp")
sourceCpp("src/stan_files/output.cpp")
install.packages(c("backports", "bayesm", "BH", "brms", "broom", "callr", "checkmate", "class", "clipr", "codetools", "colorspace", "commonmark", "curl", "data.table", "dbplyr", "e1071", "effects", "feather", "forecast", "future", "gclus", "ggmap", "git2r", "glmmTMB", "gplots", "haven", "Hmisc", "htmlTable", "httpuv", "httr", "jomo", "jsonlite", "kableExtra", "knitr", "laeken", "lessR", "lme4", "markdown", "mclust", "mgcv", "mitml", "mlogit", "OpenMx", "openssl", "overlapping", "packrat", "pillar", "plm", "prabclus", "pracma", "processx", "ps", "psych", "purrr", "quantreg", "rcmdcheck", "RcppArmadillo", "readr", "readxl", "repr", "rio", "RJSONIO", "rlang", "rmarkdown", "rms", "rsconnect", "RSGHB", "rstanarm", "rstudioapi", "slam", "SnowballC", "spam", "StanHeaders", "survey", "survival", "TH.data", "tibble", "tinytex", "tm", "tseries"))
options(rccp.cpp.dir="cache")
model_src <- stanc_builder("src/stan_files/SimulationFunctions.stan")
expose_stan_functions(model_src, cacheDir = "cache")
# MDCEV Model with fixed parameters estimated using MLE or Stan
# Notes:
# Includes LES, Gamma, and Alpha specifications as options
# One set of psi parameters for individual and alternative-specific variables and interactions
# Load Packages ------------------------------------#
rm(list=ls(all=TRUE))
ls()
library(pacman)
p_load(tidyverse, R.matlab, reshape2, rstan, rmdcev)
source("r/helperFunctions.R")
#---------------------------------------------------------------------------------------
# user input
nobs <- 1000 # number of individuals
inc <- 100000 + runif(nobs, 0, 50000) # budget
ngoods <- 10 # number of goods
price <- 5 + matrix(runif(nobs*ngoods, 0, 100), nobs, ngoods)  # price of non-numeraire good
price_num <- 1
nerrs <- 1
weight <- 1 #Modify if weights are used
nsims <- 1
algo_gen <- 0
model_specification <- "gamma"
beta <- c(-7, 0.5, 2, -1.5, 3, -2, 1, 2)
gamma <- 1 + runif(ngoods, 0, 2)
scale <- 1
fixed_scale <- 0
#---------------------------------------------------------------------------------------
if (model_specification == "alpha"){
model_type <- 1
alpha <- c(0.8, rep(0, ngoods))
parms_true <- c(beta, gamma, alpha[1], scale)
} else if (model_specification == "alpha"){
model_type <- 2
alpha <- 0 + runif(ngoods+1, 0.01, .98)
gamma <- rep(1, ngoods)
parms_true <- c(beta, alpha, scale)
} else if (model_specification == "gamma"){
model_type <- 3
alpha <- rep(0.5, ngoods+1)
parms_true <- c(beta, gamma, alpha[1], scale)
} else if (model_specification == "gamma0"){
model_type <- 4
alpha <- rep(0, ngoods+1)
parms_true <- c(beta, gamma, scale)
} else
stop("No model specificied. Choose a model_specification")
parms_true <- tbl_df(parms_true) %>%
rename(parms_true = value)
# Create psi variables that vary over alternatives
b1 <- rep(1,ngoods)
b2 <- rbinom(ngoods, 1, 0.5)
b3 <- rbinom(ngoods, 1, 0.5)
psi_j_temp <- list(b1 = b1,
b2 = b2,
b3 = b3)
# Create psi variables that vary by person
psi_socio = 2*matrix(runif(nobs * (length(beta)-3)), nobs,length(beta)-3)
psi_i_temp <- list(b4 = psi_socio[,1],
b5 = psi_socio[,2],
b5 = psi_socio[,3],
b5 = psi_socio[,4],
b5 = psi_socio[,5])
# Create full set of base psi variables
psi_j_temp <- map(psi_j_temp, function(x) {rep(x, each=nobs)})
psi_i_temp <- map(psi_i_temp, function(x) {rep(x, times= ngoods)})
dat_psi = c(psi_j_temp, psi_i_temp)
dat_psi = matrix(unlist(dat_psi), ncol = length(beta))
psi_sims <- matrix(dat_psi %*% beta, ncol = ngoods, byrow = TRUE)
psi_sims <- CreateListsRow(psi_sims)
psi_sims <- list(psi_sims )
names(psi_sims) <- "psi_sims"
inc_list <- list(as.list(inc))
names(inc_list) <- "inc" # price normalized MU at zero
price_list <- cbind(1, price) #add numeraire price to price matrix (<-1)
price_list <- list(CreateListsRow(price_list))
names(price_list) <- "price" # price normalized MU at zero
###########################################################################
# Pull individual level data into one list
###########################################################################
df_temp <- c(inc_list, price_list, psi_sims)
# choose number of people to simulate (set to nobs for all)
nobs_sims <- nobs
df_subset <- lapply(df_temp, "[", c(1:nobs_sims))
# To try and get expose as part of package
options(rccp.cpp.dir="cache")
model_src <- stanc_builder("src/stan_files/SimulationFunctions.stan")
expose_stan_functions(model_src, cacheDir = "cache")
library(rmdcev)
library(rmdcev)
?rmdcev
warnings()
sourceCpp("C:/Dropbox/Research/code/rmdcev/src/SimFunctions.cpp")
stanc_builder
# MDCEV Model with fixed parameters estimated using MLE or Stan
# Notes:
# Includes LES, Gamma, and Alpha specifications as options
# One set of psi parameters for individual and alternative-specific variables and interactions
# Load Packages ------------------------------------#
rm(list=ls(all=TRUE))
ls()
library(pacman)
p_load(tidyverse, R.matlab, reshape2, rstan, rmdcev)
source("r/helperFunctions.R")
#---------------------------------------------------------------------------------------
# user input
nobs <- 1000 # number of individuals
inc <- 100000 + runif(nobs, 0, 50000) # budget
ngoods <- 10 # number of goods
price <- 5 + matrix(runif(nobs*ngoods, 0, 100), nobs, ngoods)  # price of non-numeraire good
price_num <- 1
nerrs <- 1
weight <- 1 #Modify if weights are used
nsims <- 1
algo_gen <- 0
model_specification <- "gamma"
beta <- c(-7, 0.5, 2, -1.5, 3, -2, 1, 2)
gamma <- 1 + runif(ngoods, 0, 2)
scale <- 1
fixed_scale <- 0
#---------------------------------------------------------------------------------------
if (model_specification == "alpha"){
model_type <- 1
alpha <- c(0.8, rep(0, ngoods))
parms_true <- c(beta, gamma, alpha[1], scale)
} else if (model_specification == "alpha"){
model_type <- 2
alpha <- 0 + runif(ngoods+1, 0.01, .98)
gamma <- rep(1, ngoods)
parms_true <- c(beta, alpha, scale)
} else if (model_specification == "gamma"){
model_type <- 3
alpha <- rep(0.5, ngoods+1)
parms_true <- c(beta, gamma, alpha[1], scale)
} else if (model_specification == "gamma0"){
model_type <- 4
alpha <- rep(0, ngoods+1)
parms_true <- c(beta, gamma, scale)
} else
stop("No model specificied. Choose a model_specification")
parms_true <- tbl_df(parms_true) %>%
rename(parms_true = value)
# Create psi variables that vary over alternatives
b1 <- rep(1,ngoods)
b2 <- rbinom(ngoods, 1, 0.5)
b3 <- rbinom(ngoods, 1, 0.5)
psi_j_temp <- list(b1 = b1,
b2 = b2,
b3 = b3)
# Create psi variables that vary by person
psi_socio = 2*matrix(runif(nobs * (length(beta)-3)), nobs,length(beta)-3)
psi_i_temp <- list(b4 = psi_socio[,1],
b5 = psi_socio[,2],
b5 = psi_socio[,3],
b5 = psi_socio[,4],
b5 = psi_socio[,5])
# Create full set of base psi variables
psi_j_temp <- map(psi_j_temp, function(x) {rep(x, each=nobs)})
psi_i_temp <- map(psi_i_temp, function(x) {rep(x, times= ngoods)})
dat_psi = c(psi_j_temp, psi_i_temp)
dat_psi = matrix(unlist(dat_psi), ncol = length(beta))
psi_sims <- matrix(dat_psi %*% beta, ncol = ngoods, byrow = TRUE)
psi_sims <- CreateListsRow(psi_sims)
psi_sims <- list(psi_sims )
names(psi_sims) <- "psi_sims"
inc_list <- list(as.list(inc))
names(inc_list) <- "inc" # price normalized MU at zero
price_list <- cbind(1, price) #add numeraire price to price matrix (<-1)
price_list <- list(CreateListsRow(price_list))
names(price_list) <- "price" # price normalized MU at zero
###########################################################################
# Pull individual level data into one list
###########################################################################
df_temp <- c(inc_list, price_list, psi_sims)
# choose number of people to simulate (set to nobs for all)
nobs_sims <- nobs
df_subset <- lapply(df_temp, "[", c(1:nobs_sims))
stanc_builder
?stanc_builder
# To try and get expose as part of package
options(rccp.cpp.dir="cache")
model_src <- stanc_builder("src/stan_files/SimulationFunctions.stan")
expose_stan_functions(model_src, cacheDir = "cache")
rm(list=ls(all=TRUE))
ls()
# Load Packages ------------------------------------#
#library(pacman)
library(pacman)
p_load(tidyverse, R.matlab, reshape2, rstan, rmdcev)
# Import Data ------------------------------------#
load("C:/Dropbox/Research/code/mdcev_test.RData")
# Set functions ------------------------------------#
source("r/helperFunctions.R")
source("r/PrepareSimulationData.R")
source("r/CreateSimulationData.R")
source("r/SimulateWTP.R")
###########################################################################
# Create policy scenarios (can affect price only at this point)
###########################################################################
npols <- 2
policies<-	CreateBlankPolicies(npols, result$stan_data[["J"]], result$stan_data[["dat_psi"]])
# Closing each site individual than all together
#price_p <- cbind(0,diag(ngoods)*10000000)
#price_p <- rbind(price_p, c(0,rep(100000000,ngoods)))# add all closures to price_list
#price_p <- rbind(c(0,100000000,rep(100000000,ngoods-1)), c(0,rep(100000000,ngoods)))# add all closures to price_list
stan_est <- result
wtp <- SimulateWTP(stan_est, policies)
View(SimulateWTP)
source('C:/Dropbox/Research/code/rmdcev/R/FitMDCEV.R')
source('C:/Dropbox/Research/code/rmdcev/R/SimulateWTP.R')
wtp <- SimulateWTP(stan_est, policies)
source('C:/Dropbox/Research/code/rmdcev/R/SimulateWTP.R')
source('C:/Dropbox/Research/code/rmdcev/R/SimulateWTP.R')
wtp <- SimulateWTP(stan_est, policies, nsims = 3)
View(SimulateWTP)
wtp <- SimulateWTP(stan_est, policies)
library(rmdcev)
library(rmdcev)
library(rmdcev)
?rmdcev
library(rmdcev)
library(rmdcev)
rm(list=ls(all=TRUE))
ls()
# Load Packages ------------------------------------#
#library(pacman)
library(pacman)
p_load(tidyverse, R.matlab, reshape2, rstan, rmdcev)
# Import Data ------------------------------------#
load("C:/Dropbox/Research/code/mdcev_test.RData")
# Set functions ------------------------------------#
source("r/helperFunctions.R")
source("r/PrepareSimulationData.R")
source("r/CreateSimulationData.R")
source("r/SimulateWTP.R")
###########################################################################
# Create policy scenarios (can affect price only at this point)
###########################################################################
npols <- 2
policies<-	CreateBlankPolicies(npols, result$stan_data[["J"]], result$stan_data[["dat_psi"]])
# Closing each site individual than all together
#price_p <- cbind(0,diag(ngoods)*10000000)
#price_p <- rbind(price_p, c(0,rep(100000000,ngoods)))# add all closures to price_list
#price_p <- rbind(c(0,100000000,rep(100000000,ngoods-1)), c(0,rep(100000000,ngoods)))# add all closures to price_list
stan_est <- result
nerrs = 4
nsims = 3
cond_error = 1
algo_gen = NULL
model_type <- stan_est$stan_data$model_type
if (!is.null(algo_gen))
if (model_type < 3 && algo_gen == 0) stop("Can't use hybrid algorithm with model_type = 1 or 2. Choose algo_gen ==1")
if (is.null(algo_gen)) {# ensure
if (model_type == 3 || model_type == 4)
algo_gen <- 0
else if (model_type == 1 || model_type == 2)
algo_gen <- 1
}
sim_options <- list(ngoods = stan_est$stan_data[["J"]],
nerrs = nerrs,
#		nsims = nsims,
npols = length(policies[["price_p"]]),
cond_error = cond_error,
algo_gen = algo_gen,
model_type = model_type)
# Prepare sim data
sim_welfare <- PrepareSimulationData(stan_est, policies)
df_common <- sim_welfare
df_common$df_temp <- NULL
df_indiv <- sim_welfare$df_indiv
wtp <- StanWTP(df_indiv, df_common, sim_options)
source('C:/Dropbox/Research/code/rmdcev/R/SimulateWTP.R')
wtp <- StanWTP(df_indiv, df_common, sim_options)
wtpcppcode <- stanc("src/stan_files/SimulationFunctions.stan",
model_name = "SimulationFunctions")
expose_stan_functions(wtpcppcode)
View(df_indiv)
wtp <- pmap(df_indiv, CalcWTP_rng,
price_p=df_common$price_p_list,
gamma_sim=df_common$gamma_sim_list,
alpha_sim=df_common$alpha_sim_list,
scale_sim=df_common$scale_sim,
ngoods=sim_options$ngoods,
nsims=sim_options$nsims,
nerrs=sim_options$nerrs,
npols=sim_options$npols,
cond_error=sim_options$cond_error,
algo_gen=sim_options$algo_gen,
model_type=sim_options$model_type)#,
View(df_common)
df_common <- sim_welfare
df_common$df_temp <- NULL
df_common$df_indiv <- NULL
df_indiv <- sim_welfare$df_indiv
wtp <- StanWTP(df_indiv, df_common, sim_options)
scale_sim=df_common$scale_sim
alpha_sim=df_common$alpha_sim_list
gamma_sim=df_common$gamma_sim_list
wtp <- StanWTP(df_indiv, df_common, sim_options)
View(CalcWTP_rng)
source('C:/Dropbox/Research/code/test_hdemand.R')
source('C:/Dropbox/Research/code/test_hdemand.R')
sum(test)
rm(list=ls(all=TRUE))
ls()
# Load Packages ------------------------------------#
#library(pacman)
library(pacman)
p_load(tidyverse, R.matlab, reshape2, rstan, rmdcev)
# Import Data ------------------------------------#
load("C:/Dropbox/Research/code/mdcev_test.RData")
# Set functions ------------------------------------#
source("r/helperFunctions.R")
source("r/PrepareSimulationData.R")
source("r/CreateSimulationData.R")
source("r/SimulateWTP.R")
###########################################################################
# Create policy scenarios (can affect price only at this point)
###########################################################################
npols <- 2
policies<-	CreateBlankPolicies(npols, result$stan_data[["J"]], result$stan_data[["dat_psi"]])
# Closing each site individual than all together
#price_p <- cbind(0,diag(ngoods)*10000000)
#price_p <- rbind(price_p, c(0,rep(100000000,ngoods)))# add all closures to price_list
#price_p <- rbind(c(0,100000000,rep(100000000,ngoods-1)), c(0,rep(100000000,ngoods)))# add all closures to price_list
stan_est <- result
wtp <- SimulateWTP(stan_est, policies)
