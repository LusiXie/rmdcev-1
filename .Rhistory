hb.warnings = TRUE, hb.beta.draws.to.keep = 0)
rep(1, 500)
# MDCEV Model with fixed parameters estimated using MLE or Stan
# Notes:
# Includes LES, Gamma, and Alpha specifications as options
# One set of psi parameters for individual and alternative-specific variables and interactions
# Load Packages ------------------------------------#
rm(list=ls(all=TRUE))
ls()
library(pacman)
p_load(tidyverse, R.matlab, reshape2, rstan, rmdcev)
#---------------------------------------------------------------------------------------
# DATA SECTION - User must load or create matrices quant, price, inc, psi, weight
#
#   Notation:
#       nobs       = # of people
#       ngoods     = # of goods included in model
#       NPsi        = # var's included in psi
#
#   Matrices:
#       quant:  nobs x ngoods matrix holding quantities consumed for all non-numeraire goods.
#       price:  nobs x ngoods matrix holding prices for all non-numeraire goods.
#       inc:    nobs x 1 vector holding annual income for all people
#       weight: nobs x 1 vector holding sample ind_weights.
#       psi:  (nobs X ngoods) x NPsi matrix holding the individual-specific variables.
# Load data
load("C:/Dropbox/Research/code/rmdcev/simulated_data.RData")
CreateLists <- function(x){
out <- lapply(seq_len(ncol(x)), function(i) x[,i])
return(out)
}
quant <- matrix(unlist(quant), nrow = nobs, byrow = TRUE)
price <- matrix(unlist(price), nrow = nobs, byrow = TRUE)
inc <- unlist(inc)
dat_psi <- CreateLists(dat_psi)
price <- price[,2:(ncol(quant))]
quant <- quant[,2:(ncol(quant))]
stan.dat <- list(quant = quant,
price = price,
inc = as.vector(inc),
dat_psi = dat_psi)
rm(nobs)
weights <-  rep(1, length(inc))
# default is one
n_classes = 1
hessian = TRUE
algorithm = "MLE"
model_specification = "gamma"
price_num = NULL
fixed_scale = 0
print_ll = 1
n_draws = 5
n_chains = 4
n_iterations = 500
#source('T:/Code/rmdcev/R/FitMDCEV.R')
#source('T:/Code/rmdcev/R/processMDCEVdata.R')
#source('T:/Code/rmdcev/R/maxLikeMDCEV.R')
#source('T:/Code/rmdcev/R/HierarchicalBayesMDCEV.R')
# initial starting values
#initial.parameters <- list(psi = rep(0,length(dat_psi)),
#						   scale = as.array(1, dim = 1),
#						   #		alpha = as.array(0.1, dim = 1),
#						   gamma = rep(1,ncol(quant)))
#devtools::install(local=TRUE)
result <- FitMDCEV(stan.dat,
dat_class = dat_class,
weights = weights,
#				   price_num = NULL,
model_specification = "gamma",
n_classes = n_classes,
fixed_scale = 0,
seed = 123,
initial.parameters = initial.parameters,
algorithm = "MLE",
#	std_errors = "draws", # still need to implement
print_ll = 0,
#mle_tol = 0.0001,
hessian = TRUE,
n_draws = 50,
keep_loglik = 0,
#subset = NULL,
hb_random_parameters = "fixed",
n_iterations = n_iterations, n_chains = n_chains,
hb.max.tree.depth = 10, hb.adapt.delta = 0.8,
hb.keep.samples = FALSE, hb.stanfit = TRUE,
#					 hb.prior.mean = 0, hb.prior.sd = 5,
#					 hb.sigma.prior.shape = 1.39435729464721,
#					 hb.sigma.prior.scale = 0.39435729464721,
hb.lkj.prior.shape = 4,
hb.warnings = TRUE, hb.beta.draws.to.keep = 0)
library(rmdcev)
# MDCEV Model with fixed parameters estimated using MLE or Stan
# Notes:
# Includes LES, Gamma, and Alpha specifications as options
# One set of psi parameters for individual and alternative-specific variables and interactions
# Load Packages ------------------------------------#
rm(list=ls(all=TRUE))
ls()
library(pacman)
p_load(tidyverse, R.matlab, reshape2, rstan, rmdcev)
#---------------------------------------------------------------------------------------
# DATA SECTION - User must load or create matrices quant, price, inc, psi, weight
#
#   Notation:
#       nobs       = # of people
#       ngoods     = # of goods included in model
#       NPsi        = # var's included in psi
#
#   Matrices:
#       quant:  nobs x ngoods matrix holding quantities consumed for all non-numeraire goods.
#       price:  nobs x ngoods matrix holding prices for all non-numeraire goods.
#       inc:    nobs x 1 vector holding annual income for all people
#       weight: nobs x 1 vector holding sample ind_weights.
#       psi:  (nobs X ngoods) x NPsi matrix holding the individual-specific variables.
# Load data
load("C:/Dropbox/Research/code/rmdcev/simulated_data.RData")
CreateLists <- function(x){
out <- lapply(seq_len(ncol(x)), function(i) x[,i])
return(out)
}
quant <- matrix(unlist(quant), nrow = nobs, byrow = TRUE)
price <- matrix(unlist(price), nrow = nobs, byrow = TRUE)
inc <- unlist(inc)
dat_psi <- CreateLists(dat_psi)
price <- price[,2:(ncol(quant))]
quant <- quant[,2:(ncol(quant))]
stan.dat <- list(quant = quant,
price = price,
inc = as.vector(inc),
dat_psi = dat_psi)
rm(nobs)
weights <-  rep(1, length(inc))
# default is one
n_classes = 1
hessian = TRUE
algorithm = "MLE"
model_specification = "gamma"
price_num = NULL
fixed_scale = 0
print_ll = 1
n_draws = 5
n_chains = 4
n_iterations = 500
#source('T:/Code/rmdcev/R/FitMDCEV.R')
#source('T:/Code/rmdcev/R/processMDCEVdata.R')
#source('T:/Code/rmdcev/R/maxLikeMDCEV.R')
#source('T:/Code/rmdcev/R/HierarchicalBayesMDCEV.R')
# initial starting values
#initial.parameters <- list(psi = rep(0,length(dat_psi)),
#						   scale = as.array(1, dim = 1),
#						   #		alpha = as.array(0.1, dim = 1),
#						   gamma = rep(1,ncol(quant)))
#devtools::install(local=TRUE)
result <- FitMDCEV(stan.dat,
dat_class = dat_class,
weights = weights,
#				   price_num = NULL,
model_specification = "gamma",
n_classes = n_classes,
fixed_scale = 0,
seed = 123,
initial.parameters = initial.parameters,
algorithm = "MLE",
#	std_errors = "draws", # still need to implement
print_ll = 0,
#mle_tol = 0.0001,
hessian = TRUE,
n_draws = 50,
keep_loglik = 0,
#subset = NULL,
hb_random_parameters = "fixed",
n_iterations = n_iterations, n_chains = n_chains,
hb.max.tree.depth = 10, hb.adapt.delta = 0.8,
hb.keep.samples = FALSE, hb.stanfit = TRUE,
#					 hb.prior.mean = 0, hb.prior.sd = 5,
#					 hb.sigma.prior.shape = 1.39435729464721,
#					 hb.sigma.prior.scale = 0.39435729464721,
hb.lkj.prior.shape = 4,
hb.warnings = TRUE, hb.beta.draws.to.keep = 0)
library(rmdcev)
# MDCEV Model with fixed parameters estimated using MLE or Stan
# Notes:
# Includes LES, Gamma, and Alpha specifications as options
# One set of psi parameters for individual and alternative-specific variables and interactions
# Load Packages ------------------------------------#
rm(list=ls(all=TRUE))
ls()
library(pacman)
p_load(tidyverse, R.matlab, reshape2, rstan, rmdcev)
#---------------------------------------------------------------------------------------
# DATA SECTION - User must load or create matrices quant, price, inc, psi, weight
#
#   Notation:
#       nobs       = # of people
#       ngoods     = # of goods included in model
#       NPsi        = # var's included in psi
#
#   Matrices:
#       quant:  nobs x ngoods matrix holding quantities consumed for all non-numeraire goods.
#       price:  nobs x ngoods matrix holding prices for all non-numeraire goods.
#       inc:    nobs x 1 vector holding annual income for all people
#       weight: nobs x 1 vector holding sample ind_weights.
#       psi:  (nobs X ngoods) x NPsi matrix holding the individual-specific variables.
# Load data
load("C:/Dropbox/Research/code/rmdcev/simulated_data.RData")
CreateLists <- function(x){
out <- lapply(seq_len(ncol(x)), function(i) x[,i])
return(out)
}
quant <- matrix(unlist(quant), nrow = nobs, byrow = TRUE)
price <- matrix(unlist(price), nrow = nobs, byrow = TRUE)
inc <- unlist(inc)
dat_psi <- CreateLists(dat_psi)
price <- price[,2:(ncol(quant))]
quant <- quant[,2:(ncol(quant))]
stan.dat <- list(quant = quant,
price = price,
inc = as.vector(inc),
dat_psi = dat_psi)
rm(nobs)
weights <-  rep(1, length(inc))
# default is one
n_classes = 1
hessian = TRUE
algorithm = "MLE"
model_specification = "gamma"
price_num = NULL
fixed_scale = 0
print_ll = 1
n_draws = 5
n_chains = 4
n_iterations = 500
#source('T:/Code/rmdcev/R/FitMDCEV.R')
#source('T:/Code/rmdcev/R/processMDCEVdata.R')
#source('T:/Code/rmdcev/R/maxLikeMDCEV.R')
#source('T:/Code/rmdcev/R/HierarchicalBayesMDCEV.R')
# initial starting values
#initial.parameters <- list(psi = rep(0,length(dat_psi)),
#						   scale = as.array(1, dim = 1),
#						   #		alpha = as.array(0.1, dim = 1),
#						   gamma = rep(1,ncol(quant)))
#devtools::install(local=TRUE)
result <- FitMDCEV(stan.dat,
dat_class = dat_class,
weights = weights,
#				   price_num = NULL,
model_specification = "gamma",
n_classes = n_classes,
fixed_scale = 0,
seed = 123,
initial.parameters = initial.parameters,
algorithm = "MLE",
#	std_errors = "draws", # still need to implement
print_ll = 0,
#mle_tol = 0.0001,
hessian = TRUE,
n_draws = 50,
keep_loglik = 0,
#subset = NULL,
hb_random_parameters = "fixed",
n_iterations = n_iterations, n_chains = n_chains,
hb.max.tree.depth = 10, hb.adapt.delta = 0.8,
hb.keep.samples = FALSE, hb.stanfit = TRUE,
#					 hb.prior.mean = 0, hb.prior.sd = 5,
#					 hb.sigma.prior.shape = 1.39435729464721,
#					 hb.sigma.prior.scale = 0.39435729464721,
hb.lkj.prior.shape = 4,
hb.warnings = TRUE, hb.beta.draws.to.keep = 0)
View(stan.dat)
stan.dat[["price"]]
stan.dat[["price"]]
# MDCEV Model with fixed parameters estimated using MLE or Stan
# Notes:
# Includes LES, Gamma, and Alpha specifications as options
# One set of psi parameters for individual and alternative-specific variables and interactions
# Load Packages ------------------------------------#
rm(list=ls(all=TRUE))
ls()
library(pacman)
p_load(tidyverse, R.matlab, reshape2, rstan, rmdcev)
library(rmdcev)
rm(list=ls(all=TRUE))
ls()
library(pacman)
p_load(tidyverse, R.matlab, reshape2, rstan, rmdcev)
#---------------------------------------------------------------------------------------
# DATA SECTION - User must load or create matrices quant, price, inc, psi, weight
#
#   Notation:
#       nobs       = # of people
#       ngoods     = # of goods included in model
#       NPsi        = # var's included in psi
#
#   Matrices:
#       quant:  nobs x ngoods matrix holding quantities consumed for all non-numeraire goods.
#       price:  nobs x ngoods matrix holding prices for all non-numeraire goods.
#       inc:    nobs x 1 vector holding annual income for all people
#       weight: nobs x 1 vector holding sample ind_weights.
#       psi:  (nobs X ngoods) x NPsi matrix holding the individual-specific variables.
# Load data
load("C:/Dropbox/Research/code/rmdcev/simulated_data.RData")
CreateLists <- function(x){
out <- lapply(seq_len(ncol(x)), function(i) x[,i])
return(out)
}
quant <- matrix(unlist(quant), nrow = nobs, byrow = TRUE)
price <- matrix(unlist(price), nrow = nobs, byrow = TRUE)
inc <- unlist(inc)
dat_psi <- CreateLists(dat_psi)
price <- price[,2:(ncol(quant))]
quant <- quant[,2:(ncol(quant))]
stan.dat <- list(quant = quant,
price = price,
inc = as.vector(inc),
dat_psi = dat_psi)
rm(nobs)
weights <-  rep(1, length(inc))
# default is one
n_classes = 1
hessian = TRUE
algorithm = "MLE"
model_specification = "gamma"
price_num = NULL
fixed_scale = 0
print_ll = 1
n_draws = 5
n_chains = 4
n_iterations = 500
#source('T:/Code/rmdcev/R/FitMDCEV.R')
#source('T:/Code/rmdcev/R/processMDCEVdata.R')
#source('T:/Code/rmdcev/R/maxLikeMDCEV.R')
#source('T:/Code/rmdcev/R/HierarchicalBayesMDCEV.R')
# initial starting values
#initial.parameters <- list(psi = rep(0,length(dat_psi)),
#						   scale = as.array(1, dim = 1),
#						   #		alpha = as.array(0.1, dim = 1),
#						   gamma = rep(1,ncol(quant)))
#devtools::install(local=TRUE)
result <- FitMDCEV(stan.dat,
dat_class = dat_class,
weights = weights,
#				   price_num = NULL,
model_specification = "gamma",
n_classes = n_classes,
fixed_scale = 0,
seed = 123,
initial.parameters = initial.parameters,
algorithm = "MLE",
#	std_errors = "draws", # still need to implement
print_ll = 0,
#mle_tol = 0.0001,
hessian = TRUE,
n_draws = 50,
keep_loglik = 0,
#subset = NULL,
hb_random_parameters = "fixed",
n_iterations = n_iterations, n_chains = n_chains,
hb.max.tree.depth = 10, hb.adapt.delta = 0.8,
hb.keep.samples = FALSE, hb.stanfit = TRUE,
#					 hb.prior.mean = 0, hb.prior.sd = 5,
#					 hb.sigma.prior.shape = 1.39435729464721,
#					 hb.sigma.prior.scale = 0.39435729464721,
hb.lkj.prior.shape = 4,
hb.warnings = TRUE, hb.beta.draws.to.keep = 0)
source('C:/Dropbox/Research/code/rmdcev/R/SimulateData.R')
# MDCEV Model with fixed parameters estimated using MLE or Stan
# Notes:
# Includes LES, Gamma, and Alpha specifications as options
# One set of psi parameters for individual and alternative-specific variables and interactions
# Load Packages ------------------------------------#
rm(list=ls(all=TRUE))
ls()
library(pacman)
p_load(tidyverse, R.matlab, reshape2, rstan, rmdcev)
#---------------------------------------------------------------------------------------
# DATA SECTION - User must load or create matrices quant, price, inc, psi, weight
#
#   Notation:
#       nobs       = # of people
#       ngoods     = # of goods included in model
#       NPsi        = # var's included in psi
#
#   Matrices:
#       quant:  nobs x ngoods matrix holding quantities consumed for all non-numeraire goods.
#       price:  nobs x ngoods matrix holding prices for all non-numeraire goods.
#       inc:    nobs x 1 vector holding annual income for all people
#       weight: nobs x 1 vector holding sample ind_weights.
#       psi:  (nobs X ngoods) x NPsi matrix holding the individual-specific variables.
# Load data
load("C:/Dropbox/Research/code/rmdcev/simulated_data.RData")
CreateLists <- function(x){
out <- lapply(seq_len(ncol(x)), function(i) x[,i])
return(out)
}
quant <- matrix(unlist(quant), nrow = nobs, byrow = TRUE)
price <- matrix(unlist(price), nrow = nobs, byrow = TRUE)
inc <- unlist(inc)
dat_psi <- CreateLists(dat_psi)
price <- price[,2:(ncol(quant))]
quant <- quant[,2:(ncol(quant))]
stan.dat <- list(quant = quant,
price = price,
inc = as.vector(inc),
dat_psi = dat_psi)
rm(nobs)
weights <-  rep(1, length(inc))
# default is one
n_classes = 1
hessian = TRUE
algorithm = "MLE"
model_specification = "gamma"
price_num = NULL
fixed_scale = 0
print_ll = 1
n_draws = 5
n_chains = 4
n_iterations = 500
#source('T:/Code/rmdcev/R/FitMDCEV.R')
#source('T:/Code/rmdcev/R/processMDCEVdata.R')
#source('T:/Code/rmdcev/R/maxLikeMDCEV.R')
#source('T:/Code/rmdcev/R/HierarchicalBayesMDCEV.R')
# initial starting values
#initial.parameters <- list(psi = rep(0,length(dat_psi)),
#						   scale = as.array(1, dim = 1),
#						   #		alpha = as.array(0.1, dim = 1),
#						   gamma = rep(1,ncol(quant)))
#devtools::install(local=TRUE)
result <- FitMDCEV(stan.dat,
dat_class = dat_class,
weights = weights,
#				   price_num = NULL,
model_specification = "gamma",
n_classes = n_classes,
fixed_scale = 0,
seed = 123,
initial.parameters = initial.parameters,
algorithm = "MLE",
#	std_errors = "draws", # still need to implement
print_ll = 0,
#mle_tol = 0.0001,
hessian = TRUE,
n_draws = 50,
keep_loglik = 0,
#subset = NULL,
hb_random_parameters = "fixed",
n_iterations = n_iterations, n_chains = n_chains,
hb.max.tree.depth = 10, hb.adapt.delta = 0.8,
hb.keep.samples = FALSE, hb.stanfit = TRUE,
#					 hb.prior.mean = 0, hb.prior.sd = 5,
#					 hb.sigma.prior.shape = 1.39435729464721,
#					 hb.sigma.prior.scale = 0.39435729464721,
hb.lkj.prior.shape = 4,
hb.warnings = TRUE, hb.beta.draws.to.keep = 0)
source('C:/Dropbox/Research/code/rmdcev/R/SimulateData.R')
# Simulation parameters
nobs <- 500 # number of individuals
inc <- 100000 + runif(nobs, 0, 50000) # budget
ngoods <- 10 # number of goods
gamma <- rep(2, ngoods)
scale <- 1
alpha <- c(0.8, rep(0, ngoods))
alpha <- rep(0.7, ngoods+1)
beta <- c(-5, 0.5, 2, -1.5, 3)
price <- 50 + matrix(runif(nobs*ngoods, 0, 100), nobs, ngoods)  # price of non-numeraire good
price_num <- 1
nerrs <- 100
weight    <- 1 #Modify if weights are used
nsims <- 1
algo_gen <- 0
model_type <- 3
fixed_scale <- 1
psi_socio = 2*matrix(runif(nobs * (length(beta)-3)), nobs,length(beta)-3)
# Create psi variables that vary over alternatives
b1 <- rep(1,ngoods)
b2 <- c(rep(1,ngoods/2), rep(0, ngoods / 2))
b3 <- rep(c(0,1), ngoods / 2)
psi_j_temp <- list(b1 = b1,
b2 = b2,
b3 = b3)
# Create psi variables that vary by person
psi_i_temp <- list(b4 = psi_socio[,1],
b5 = psi_socio[,2])
CreateLists <- function(x){
out <- lapply(seq_len(nrow(x)), function(i) x[i,])
return(out)
}
# Create full set of base psi variables
psi_j_temp <- map(psi_j_temp, function(x) {rep(x, each=nobs)})
psi_i_temp <- map(psi_i_temp, function(x) {rep(x, times= ngoods)})
dat_psi = c(psi_j_temp, psi_i_temp)
dat_psi = matrix(unlist(dat_psi), ncol = length(beta))
source('C:/Dropbox/Research/code/rmdcev/R/CreateSimulationData.R')
psi_sim <- matrix(dat_psi %*% beta, ncol = ngoods, byrow = TRUE)
psi_sim <- CreateLists(psi_sim)
psi_sim <- list(psi_sim )
names(psi_sim) <- "psi_sim"
inc <- list(as.list(inc))
names(inc) <- "inc" # price normalized MU at zero
price <- cbind(1, price) #add numeraire price to price matrix (<-1)
price <- list(CreateLists(price))
names(price) <- "price" # price normalized MU at zero
###########################################################################
# Pull individual level data into one list
###########################################################################
df_temp <- c(inc, price, psi_sim)
# choose number of people to simulate (set to nobs for all)
nobs_sims <- nobs
df_subset <- lapply(df_temp, "[", c(1:nobs_sims))
wtpcppcode <- stanc("src/stan_files/CalcWTP.stan",
model_name = "CalcWTP")
expose_stan_functions(wtpcppcode)
expose_stan_functions(wtpcppcode)
