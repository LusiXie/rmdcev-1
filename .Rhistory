initial.parameters = initial.parameters,
algorithm = algorithm,
#	std_errors = "draws", # still need to implement
print_ll = 0,
#mle_tol = 0.0001,
hessian = TRUE,
n_draws = 50,
keep_loglik = 0,
#subset = NULL,
hb_random_parameters = "fixed",
n_iterations = n_iterations, n_chains = n_chains)
resultt <- FitMDCEV(stan.dat,
dat_class = dat_class,
weights = weights,
#				   price_num = NULL,
model_specification = model_specification,
n_classes = n_classes,
fixed_scale = fixed_scale,
trunc_data = 1,
seed = 123,
initial.parameters = initial.parameters,
algorithm = algorithm,
#	std_errors = "draws", # still need to implement
print_ll = 0,
#mle_tol = 0.0001,
hessian = TRUE,
n_draws = 50,
keep_loglik = 0,
#subset = NULL,
hb_random_parameters = "fixed",
n_iterations = n_iterations, n_chains = n_chains)
result <- FitMDCEV(stan.dat,
dat_class = dat_class,
#					weights = weights,
#				   price_num = NULL,
model_specification = model_specification,
n_classes = n_classes,
fixed_scale = fixed_scale,
trunc_data = trunc_data,
seed = 123,
initial.parameters = initial.parameters,
algorithm = algorithm,
#	std_errors = "draws", # still need to implement
print_ll = 0,
#mle_tol = 0.0001,
hessian = TRUE,
n_draws = 50,
keep_loglik = 0,
#subset = NULL,
hb_random_parameters = "fixed",
n_iterations = n_iterations, n_chains = n_chains)
resultt <- FitMDCEV(stan.dat,
dat_class = dat_class,
#	   weights = weights,
#				   price_num = NULL,
model_specification = model_specification,
n_classes = n_classes,
fixed_scale = fixed_scale,
trunc_data = 1,
seed = 123,
initial.parameters = initial.parameters,
algorithm = algorithm,
#	std_errors = "draws", # still need to implement
print_ll = 0,
#mle_tol = 0.0001,
hessian = TRUE,
n_draws = 50,
keep_loglik = 0,
#subset = NULL,
hb_random_parameters = "fixed",
n_iterations = n_iterations, n_chains = n_chains)
library(rmdcev)
result <- FitMDCEV(stan.dat,
dat_class = dat_class,
#					weights = weights,
#				   price_num = NULL,
model_specification = model_specification,
n_classes = n_classes,
fixed_scale = fixed_scale,
trunc_data = trunc_data,
seed = 123,
initial.parameters = initial.parameters,
algorithm = algorithm,
#	std_errors = "draws", # still need to implement
print_ll = 0,
#mle_tol = 0.0001,
hessian = TRUE,
n_draws = 50,
keep_loglik = 0,
#subset = NULL,
hb_random_parameters = "fixed",
n_iterations = n_iterations, n_chains = n_chains)
resultt <- FitMDCEV(stan.dat,
dat_class = dat_class,
#	   weights = weights,
#				   price_num = NULL,
model_specification = model_specification,
n_classes = n_classes,
fixed_scale = fixed_scale,
trunc_data = 1,
seed = 123,
initial.parameters = initial.parameters,
algorithm = algorithm,
#	std_errors = "draws", # still need to implement
print_ll = 0,
#mle_tol = 0.0001,
hessian = TRUE,
n_draws = 50,
keep_loglik = 0,
#subset = NULL,
hb_random_parameters = "fixed",
n_iterations = n_iterations, n_chains = n_chains)
library(rmdcev)
dat < stan_data
library(rmdcev)
# MDCEV Model with fixed parameters estimated using MLE or Stan
# Notes:
# Includes LES, Gamma, and Alpha specifications as options
# One set of psi parameters for individual and alternative-specific variables and interactions
# Load Packages ------------------------------------#
rm(list=ls(all=TRUE))
ls()
library(pacman)
p_load(tidyverse, R.matlab, reshape2, rstan, rmdcev)
#---------------------------------------------------------------------------------------
# DATA SECTION - User must load or create matrices quant, price, inc, psi, weight
#
#   Notation:
#       nobs       = # of people
#       ngoods     = # of goods included in model
#       NPsi        = # var's included in psi
#
#   Matrices:
#       quant:  nobs x ngoods matrix holding quantities consumed for all non-numeraire goods.
#       price:  nobs x ngoods matrix holding prices for all non-numeraire goods.
#       inc:    nobs x 1 vector holding annual income for all people
#       weight: nobs x 1 vector holding sample ind_weights.
#       psi:  (nobs X ngoods) x NPsi matrix holding the individual-specific variables.
# Load data
df <- readMat("T:/Code/rMDCEV_old/Data/HeadboatDataSPTimeVarying.mat")
quant <- df$quant
price <- df$price
inc <- df$inc
ngoods <- ncol(quant)
nobs <- length(inc)
# Choose ind_weights or replace with vector of one's
#weight <-  rep.int(1, nobs)
weights <- as.vector(df$weight)
# Create psi variables that vary over alternatives
full <- c(0,0,0,0,1,1,1,1)
winter <- c(1,0,0,0,1,0,0,0)
june <- c(0,1,0,0,0,1,0,0)
summer <- c(0,0,1,0,0,0,1,0)
psi_j_temp <- list(constant = rep(1,ngoods),
full = full,
winter = winter,
june = june,
summer = summer)
# Create psi variables that vary by person
psi_i_temp <- list(ageindex = df$ageindex,
nwfl = df$reg.nwfl,
children = df$children,
male = df$male,
homegom = df$homegom)
dat_class <- cbind(df$ageindex,
df$reg.nwfl,
df$children,
df$male,
df$homegom)
# Create full set of base psi variables
#psi_j_temp <- map(psi_j_temp, function(x) {rep(x, each=nobs)})
#psi_i_temp <- map(psi_i_temp, function(x) {rep(x, times= ngoods)})
psi_j_temp <- map(psi_j_temp, function(x) {rep(x, times=nobs)})
#psi_i_temp <- map(psi_i_temp, function(x) {rep(x, each= ngoods)})
#------------------------------------#
# Interactions
#------------------------------------#
# Name and add interactions by calling specific psi_j and psi_i variables
#psi_ij <- list(summer_children = psi_j_temp[["summer"]] * psi_i_temp[["children"]])
# psi_ij <- NULL # Use if no interactions
# Combine all psi variables into one matrix
#dat_psi = c(psi_i_temp, psi_j_temp, psi_ij)
dat_psi <- c(psi_j_temp)
stan.dat <- list(quant = quant,
price = price,
inc = inc,
dat_psi = dat_psi)
# default is one
price.num = NULL
n_classes = 1
hessian = TRUE
algorithm = "MLE"
model_specification = "gamma"
price_num = NULL
fixed_scale = 1
trunc_data = 0
print_ll = 1
n_draws = 5
n_chains = 4
n_iterations = 500
#source('T:/Code/rmdcev/R/FitMDCEV.R')
#source('T:/Code/rmdcev/R/processMDCEVdata.R')
#source('T:/Code/rmdcev/R/maxLikeMDCEV.R')
#source('T:/Code/rmdcev/R/HierarchicalBayesMDCEV.R')
# initial starting values
#initial.parameters <- list(psi = rep(0,length(dat_psi)),
#						   scale = as.array(1, dim = 1),
#						   #		alpha = as.array(0.1, dim = 1),
#						   gamma = rep(1,ncol(quant)))
#devtools::install(local=TRUE)
result <- FitMDCEV(stan.dat,
dat_class = dat_class,
#					weights = weights,
#				   price_num = NULL,
model_specification = model_specification,
n_classes = n_classes,
fixed_scale = fixed_scale,
trunc_data = trunc_data,
seed = 123,
initial.parameters = initial.parameters,
algorithm = algorithm,
#	std_errors = "draws", # still need to implement
print_ll = 0,
#mle_tol = 0.0001,
hessian = TRUE,
n_draws = 50,
keep_loglik = 0,
#subset = NULL,
hb_random_parameters = "fixed",
n_iterations = n_iterations, n_chains = n_chains)
library(rmdcev)
# MDCEV Model with fixed parameters estimated using MLE or Stan
# Notes:
# Includes LES, Gamma, and Alpha specifications as options
# One set of psi parameters for individual and alternative-specific variables and interactions
# Load Packages ------------------------------------#
rm(list=ls(all=TRUE))
ls()
library(pacman)
p_load(tidyverse, R.matlab, reshape2, rstan, rmdcev)
#---------------------------------------------------------------------------------------
# DATA SECTION - User must load or create matrices quant, price, inc, psi, weight
#
#   Notation:
#       nobs       = # of people
#       ngoods     = # of goods included in model
#       NPsi        = # var's included in psi
#
#   Matrices:
#       quant:  nobs x ngoods matrix holding quantities consumed for all non-numeraire goods.
#       price:  nobs x ngoods matrix holding prices for all non-numeraire goods.
#       inc:    nobs x 1 vector holding annual income for all people
#       weight: nobs x 1 vector holding sample ind_weights.
#       psi:  (nobs X ngoods) x NPsi matrix holding the individual-specific variables.
# Load data
df <- readMat("T:/Code/rMDCEV_old/Data/HeadboatDataSPTimeVarying.mat")
quant <- df$quant
price <- df$price
inc <- df$inc
ngoods <- ncol(quant)
nobs <- length(inc)
# Choose ind_weights or replace with vector of one's
#weight <-  rep.int(1, nobs)
weights <- as.vector(df$weight)
# Create psi variables that vary over alternatives
full <- c(0,0,0,0,1,1,1,1)
winter <- c(1,0,0,0,1,0,0,0)
june <- c(0,1,0,0,0,1,0,0)
summer <- c(0,0,1,0,0,0,1,0)
psi_j_temp <- list(constant = rep(1,ngoods),
full = full,
winter = winter,
june = june,
summer = summer)
# Create psi variables that vary by person
psi_i_temp <- list(ageindex = df$ageindex,
nwfl = df$reg.nwfl,
children = df$children,
male = df$male,
homegom = df$homegom)
dat_class <- cbind(df$ageindex,
df$reg.nwfl,
df$children,
df$male,
df$homegom)
# Create full set of base psi variables
#psi_j_temp <- map(psi_j_temp, function(x) {rep(x, each=nobs)})
#psi_i_temp <- map(psi_i_temp, function(x) {rep(x, times= ngoods)})
psi_j_temp <- map(psi_j_temp, function(x) {rep(x, times=nobs)})
#psi_i_temp <- map(psi_i_temp, function(x) {rep(x, each= ngoods)})
#------------------------------------#
# Interactions
#------------------------------------#
# Name and add interactions by calling specific psi_j and psi_i variables
#psi_ij <- list(summer_children = psi_j_temp[["summer"]] * psi_i_temp[["children"]])
# psi_ij <- NULL # Use if no interactions
# Combine all psi variables into one matrix
#dat_psi = c(psi_i_temp, psi_j_temp, psi_ij)
dat_psi <- c(psi_j_temp)
stan.dat <- list(quant = quant,
price = price,
inc = inc,
dat_psi = dat_psi)
# default is one
price.num = NULL
n_classes = 1
hessian = TRUE
algorithm = "MLE"
model_specification = "gamma"
price_num = NULL
fixed_scale = 1
trunc_data = 0
print_ll = 1
n_draws = 5
n_chains = 4
n_iterations = 500
#source('T:/Code/rmdcev/R/FitMDCEV.R')
#source('T:/Code/rmdcev/R/processMDCEVdata.R')
#source('T:/Code/rmdcev/R/maxLikeMDCEV.R')
#source('T:/Code/rmdcev/R/HierarchicalBayesMDCEV.R')
# initial starting values
#initial.parameters <- list(psi = rep(0,length(dat_psi)),
#						   scale = as.array(1, dim = 1),
#						   #		alpha = as.array(0.1, dim = 1),
#						   gamma = rep(1,ncol(quant)))
#devtools::install(local=TRUE)
dat <- stan_data
dat <- stan.data
dat <- stan.dat
stan_data <- processMDCEVdata(dat, dat_class, price_num, model_options)
model_options <- list(fixed_scale = fixed_scale,
model_specification = model_specification,
n_classes = n_classes,
fixed_scale = fixed_scale,
trunc_data = trunc_data,
print_ll = print_ll,
hessian = TRUE,
n_draws = 50,
keep_loglik = 0)
hb_options <- list(n_iterations = n_iterations, n_chains = n_chains,
hb.max.tree.depth = 10, hb.adapt.delta = 0.8,
hb.keep.samples = FALSE, hb.stanfit = TRUE,
#					 hb.prior.mean = 0, hb.prior.sd = 5,
#					 hb.sigma.prior.shape = 1.39435729464721,
#					 hb.sigma.prior.scale = 0.39435729464721,
hb.lkj.prior.shape = 4,
hb.warnings = TRUE, hb.beta.draws.to.keep = 0)
stan_data <- processMDCEVdata(dat, dat_class, price_num, model_options)
# Replace weights with vector of one's if missing
if (is.null(weights))
weights <-  rep(1, stan_data$I)
stan_data$weights <- as.vector(weights)
stan_data$print_ll <- print_ll
stan.model <- stanmodels$mdcev
compiled_mle <- stan(file = "src/stan_files/mdcev.stan",  data=stan_data,
chains = 0, iter = 0)
# Estimate the model
start_time <- Sys.time()
mdcev_mle = optimizing(object=get_stanmodel(compiled_mle),
data = stan_data,
as_vector = FALSE,
hessian = TRUE,
draws = n_draws)
end_time <- Sys.time()
end_time - start_time
weights <-  rep(1, stan_data$I)
stan_data$weights <- as.vector(weights)
# Estimate the model
start_time <- Sys.time()
mdcev_mle = optimizing(object=get_stanmodel(compiled_mle),
data = stan_data,
as_vector = FALSE,
hessian = TRUE,
draws = n_draws)
end_time <- Sys.time()
end_time - start_time
library(rmdcev)
# MDCEV Model with fixed parameters estimated using MLE or Stan
# Notes:
# Includes LES, Gamma, and Alpha specifications as options
# One set of psi parameters for individual and alternative-specific variables and interactions
# Load Packages ------------------------------------#
rm(list=ls(all=TRUE))
ls()
library(pacman)
p_load(tidyverse, R.matlab, reshape2, rstan, rmdcev)
#---------------------------------------------------------------------------------------
# DATA SECTION - User must load or create matrices quant, price, inc, psi, weight
#
#   Notation:
#       nobs       = # of people
#       ngoods     = # of goods included in model
#       NPsi        = # var's included in psi
#
#   Matrices:
#       quant:  nobs x ngoods matrix holding quantities consumed for all non-numeraire goods.
#       price:  nobs x ngoods matrix holding prices for all non-numeraire goods.
#       inc:    nobs x 1 vector holding annual income for all people
#       weight: nobs x 1 vector holding sample ind_weights.
#       psi:  (nobs X ngoods) x NPsi matrix holding the individual-specific variables.
# Load data
df <- readMat("T:/Code/rMDCEV_old/Data/HeadboatDataSPTimeVarying.mat")
quant <- df$quant
price <- df$price
inc <- df$inc
ngoods <- ncol(quant)
nobs <- length(inc)
# Choose ind_weights or replace with vector of one's
#weight <-  rep.int(1, nobs)
weights <- as.vector(df$weight)
# Create psi variables that vary over alternatives
full <- c(0,0,0,0,1,1,1,1)
winter <- c(1,0,0,0,1,0,0,0)
june <- c(0,1,0,0,0,1,0,0)
summer <- c(0,0,1,0,0,0,1,0)
psi_j_temp <- list(constant = rep(1,ngoods),
full = full,
winter = winter,
june = june,
summer = summer)
# Create psi variables that vary by person
psi_i_temp <- list(ageindex = df$ageindex,
nwfl = df$reg.nwfl,
children = df$children,
male = df$male,
homegom = df$homegom)
dat_class <- cbind(df$ageindex,
df$reg.nwfl,
df$children,
df$male,
df$homegom)
# Create full set of base psi variables
#psi_j_temp <- map(psi_j_temp, function(x) {rep(x, each=nobs)})
#psi_i_temp <- map(psi_i_temp, function(x) {rep(x, times= ngoods)})
psi_j_temp <- map(psi_j_temp, function(x) {rep(x, times=nobs)})
#psi_i_temp <- map(psi_i_temp, function(x) {rep(x, each= ngoods)})
#------------------------------------#
# Interactions
#------------------------------------#
# Name and add interactions by calling specific psi_j and psi_i variables
#psi_ij <- list(summer_children = psi_j_temp[["summer"]] * psi_i_temp[["children"]])
# psi_ij <- NULL # Use if no interactions
# Combine all psi variables into one matrix
#dat_psi = c(psi_i_temp, psi_j_temp, psi_ij)
dat_psi <- c(psi_j_temp)
stan.dat <- list(quant = quant,
price = price,
inc = inc,
dat_psi = dat_psi)
# default is one
price.num = NULL
n_classes = 1
hessian = TRUE
algorithm = "MLE"
model_specification = "gamma"
price_num = NULL
fixed_scale = 1
trunc_data = 0
print_ll = 1
n_draws = 5
n_chains = 4
n_iterations = 500
#source('T:/Code/rmdcev/R/FitMDCEV.R')
#source('T:/Code/rmdcev/R/processMDCEVdata.R')
#source('T:/Code/rmdcev/R/maxLikeMDCEV.R')
#source('T:/Code/rmdcev/R/HierarchicalBayesMDCEV.R')
# initial starting values
#initial.parameters <- list(psi = rep(0,length(dat_psi)),
#						   scale = as.array(1, dim = 1),
#						   #		alpha = as.array(0.1, dim = 1),
#						   gamma = rep(1,ncol(quant)))
#devtools::install(local=TRUE)
result <- FitMDCEV(stan.dat,
dat_class = dat_class,
#					weights = weights,
#				   price_num = NULL,
model_specification = model_specification,
n_classes = n_classes,
fixed_scale = fixed_scale,
trunc_data = trunc_data,
seed = 123,
initial.parameters = initial.parameters,
algorithm = algorithm,
#	std_errors = "draws", # still need to implement
print_ll = 0,
#mle_tol = 0.0001,
hessian = TRUE,
n_draws = 50,
keep_loglik = 0,
#subset = NULL,
hb_random_parameters = "fixed",
n_iterations = n_iterations, n_chains = n_chains)
resultt <- FitMDCEV(stan.dat,
dat_class = dat_class,
#	   weights = weights,
#				   price_num = NULL,
model_specification = model_specification,
n_classes = n_classes,
fixed_scale = fixed_scale,
trunc_data = 1,
seed = 123,
initial.parameters = initial.parameters,
algorithm = algorithm,
#	std_errors = "draws", # still need to implement
print_ll = 0,
#mle_tol = 0.0001,
hessian = TRUE,
n_draws = 50,
keep_loglik = 0,
#subset = NULL,
hb_random_parameters = "fixed",
n_iterations = n_iterations, n_chains = n_chains)
