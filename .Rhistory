model_num <- 3
alpha <- rep(0.5, ngoods+1)
parms_true <- c(beta, gamma, alpha[1], scale)
} else if (model == "gamma0"){
model_num <- 4
alpha <- rep(1e-6, ngoods+1)
parms_true <- c(beta, gamma, scale)
} else
stop("No model specificied. Choose a model")
# Create psi variables that vary over alternatives
b1 <- rep(1,ngoods)
b2 <- c(rep(1,ngoods/2), rep(0, ngoods / 2))
b3 <- rep(c(0,1), ngoods / 2)
psi_j_temp <- list(b1 = b1,
b2 = b2,
b3 = b3)
# Create psi variables that vary by person
psi_socio = 2*matrix(runif(nobs * (length(beta)-3)), nobs,length(beta)-3)
psi_i_temp <- list(b4 = psi_socio[,1],
b5 = psi_socio[,2],
b5 = psi_socio[,3],
b5 = psi_socio[,4],
b5 = psi_socio[,5])
# Create full set of base psi variables
psi_j_temp <- map(psi_j_temp, function(x) {rep(x, each=nobs)})
psi_i_temp <- map(psi_i_temp, function(x) {rep(x, times= ngoods)})
dat_psi = c(psi_j_temp, psi_i_temp)
dat_psi = matrix(unlist(dat_psi), ncol = length(beta))
psi_sims <- matrix(dat_psi %*% beta, ncol = ngoods, byrow = TRUE)
psi_sims <- CreateListsRow(psi_sims)
psi_sims <- list(psi_sims )
names(psi_sims) <- "psi_sims"
inc_list <- list(as.list(inc))
names(inc_list) <- "inc" # price normalized MU at zero
price_list <- cbind(1, price) #add numeraire price to price matrix (<-1)
price_list <- list(CreateListsRow(price_list))
names(price_list) <- "price" # price normalized MU at zero
df_temp <- c(inc_list, price_list, psi_sims)
quant <- pmap(df_temp, CalcmdemandOne_rng,
gamma_sim=gamma,
alpha_sim=alpha,
scale_sim=scale,
nerrs=nerrs,algo_gen = 0)
# Convert simulated data into estimation data
quant <- matrix(unlist(quant), nrow = nobs, byrow = TRUE)
quant <- quant[,2:(ncol(quant))]
stan.dat <- list(quant = quant,
price = price,
inc = as.vector(inc),
dat_psi = dat_psi)
weights <-  rep(1, length(inc))
stan_est <- FitMDCEV(stan.dat,
model = model,
n_classes = n_classes,
fixed_scale = fixed_scale,
trunc_data = trunc_data,
seed = 123,
algorithm = "MLE",
n_iterations = n_iterations, n_chains = n_chains,
hb_random_parameters = hb_random_parameters,
print_ll = 0,
hessian = TRUE,
n_draws = n_draws,
keep_loglik = 0)
inc <- 100000 + runif(nobs, 0, 50000) # budget
price <- 5 + matrix(runif(nobs*ngoods, 0, 100), nobs, ngoods)  # price of non-numeraire good
beta <- c(-5, 0.5, 2, -1.5, 3, -2, 1, 2)
gamma <- 1 + runif(ngoods, 0, 2)
scale <- 1
if (model == "les"){
model_num <- 1
alpha <- c(0.8, rep(0, ngoods))
parms_true <- c(beta, gamma, alpha[1], scale)
} else if (model == "alpha"){
model_num <- 2
alpha <- 0 + runif(ngoods+1, 0.01, .98)
gamma <- rep(1, ngoods)
parms_true <- c(beta, alpha, scale)
} else if (model == "gamma"){
model_num <- 3
alpha <- rep(0.5, ngoods+1)
parms_true <- c(beta, gamma, alpha[1], scale)
} else if (model == "gamma0"){
model_num <- 4
alpha <- rep(1e-6, ngoods+1)
parms_true <- c(beta, gamma, scale)
} else
stop("No model specificied. Choose a model")
# Create psi variables that vary over alternatives
b1 <- rep(1,ngoods)
b2 <- c(rep(1,ngoods/2), rep(0, ngoods / 2))
b3 <- rep(c(0,1), ngoods / 2)
psi_j_temp <- list(b1 = b1,
b2 = b2,
b3 = b3)
# Create psi variables that vary by person
psi_socio = 2*matrix(runif(nobs * (length(beta)-3)), nobs,length(beta)-3)
psi_i_temp <- list(b4 = psi_socio[,1],
b5 = psi_socio[,2],
b5 = psi_socio[,3],
b5 = psi_socio[,4],
b5 = psi_socio[,5])
# Create full set of base psi variables
psi_j_temp <- map(psi_j_temp, function(x) {rep(x, each=nobs)})
psi_i_temp <- map(psi_i_temp, function(x) {rep(x, times= ngoods)})
dat_psi = c(psi_j_temp, psi_i_temp)
dat_psi = matrix(unlist(dat_psi), ncol = length(beta))
psi_sims <- matrix(dat_psi %*% beta, ncol = ngoods, byrow = TRUE)
psi_sims <- CreateListsRow(psi_sims)
psi_sims <- list(psi_sims )
names(psi_sims) <- "psi_sims"
inc_list <- list(as.list(inc))
names(inc_list) <- "inc" # price normalized MU at zero
price_list <- cbind(1, price) #add numeraire price to price matrix (<-1)
price_list <- list(CreateListsRow(price_list))
names(price_list) <- "price" # price normalized MU at zero
df_temp <- c(inc_list, price_list, psi_sims)
quant <- pmap(df_temp, CalcmdemandOne_rng,
gamma_sim=gamma,
alpha_sim=alpha,
scale_sim=scale,
nerrs=nerrs,algo_gen = 0)
# Convert simulated data into estimation data
quant <- matrix(unlist(quant), nrow = nobs, byrow = TRUE)
quant <- quant[,2:(ncol(quant))]
stan.dat <- list(quant = quant,
price = price,
inc = as.vector(inc),
dat_psi = dat_psi)
weights <-  rep(1, length(inc))
stan_est <- FitMDCEV(stan.dat,
model = model,
n_classes = n_classes,
fixed_scale = fixed_scale,
trunc_data = trunc_data,
seed = 123,
algorithm = "MLE",
n_iterations = n_iterations, n_chains = n_chains,
hb_random_parameters = hb_random_parameters,
print_ll = 0,
hessian = TRUE,
n_draws = n_draws,
keep_loglik = 0)
#library(tidyverse, rstan, rmdcev)
nerrs <- 30
nsims <- 3
nobs <- 1000 # number of individuals
ngoods <- 10 # number of goods
model <- "gamma"
cond_error = 1
fixed_scale = 0
trunc_data = 0
# default is one
n_classes = 1
n_draws = 50
n_chains = 1
n_cores = 1
n_iterations = 10
hb_random_parameters = "fixed"
inc <- 100000 + runif(nobs, 0, 50000) # budget
price <- 5 + matrix(runif(nobs*ngoods, 0, 100), nobs, ngoods)  # price of non-numeraire good
beta <- c(-5, 0.5, 2, -1.5, 3, -2, 1, 2)
gamma <- 1 + runif(ngoods, 0, 2)
scale <- 1
if (model == "les"){
model_num <- 1
alpha <- c(0.8, rep(0, ngoods))
parms_true <- c(beta, gamma, alpha[1], scale)
} else if (model == "alpha"){
model_num <- 2
alpha <- 0 + runif(ngoods+1, 0.01, .98)
gamma <- rep(1, ngoods)
parms_true <- c(beta, alpha, scale)
} else if (model == "gamma"){
model_num <- 3
alpha <- rep(0.5, ngoods+1)
parms_true <- c(beta, gamma, alpha[1], scale)
} else if (model == "gamma0"){
model_num <- 4
alpha <- rep(1e-6, ngoods+1)
parms_true <- c(beta, gamma, scale)
} else
stop("No model specificied. Choose a model")
# Create psi variables that vary over alternatives
b1 <- rep(1,ngoods)
b2 <- c(rep(1,ngoods/2), rep(0, ngoods / 2))
b3 <- rep(c(0,1), ngoods / 2)
psi_j_temp <- list(b1 = b1,
b2 = b2,
b3 = b3)
# Create psi variables that vary by person
psi_socio = 2*matrix(runif(nobs * (length(beta)-3)), nobs,length(beta)-3)
psi_i_temp <- list(b4 = psi_socio[,1],
b5 = psi_socio[,2],
b5 = psi_socio[,3],
b5 = psi_socio[,4],
b5 = psi_socio[,5])
# Create full set of base psi variables
psi_j_temp <- map(psi_j_temp, function(x) {rep(x, each=nobs)})
psi_i_temp <- map(psi_i_temp, function(x) {rep(x, times= ngoods)})
dat_psi = c(psi_j_temp, psi_i_temp)
dat_psi = matrix(unlist(dat_psi), ncol = length(beta))
psi_sims <- matrix(dat_psi %*% beta, ncol = ngoods, byrow = TRUE)
psi_sims <- CreateListsRow(psi_sims)
psi_sims <- list(psi_sims )
names(psi_sims) <- "psi_sims"
inc_list <- list(as.list(inc))
names(inc_list) <- "inc" # price normalized MU at zero
price_list <- cbind(1, price) #add numeraire price to price matrix (<-1)
price_list <- list(CreateListsRow(price_list))
names(price_list) <- "price" # price normalized MU at zero
df_temp <- c(inc_list, price_list, psi_sims)
quant <- pmap(df_temp, CalcmdemandOne_rng,
gamma_sim=gamma,
alpha_sim=alpha,
scale_sim=scale,
nerrs=nerrs,algo_gen = 0)
# Convert simulated data into estimation data
quant <- matrix(unlist(quant), nrow = nobs, byrow = TRUE)
quant <- quant[,2:(ncol(quant))]
stan.dat <- list(quant = quant,
price = price,
inc = as.vector(inc),
dat_psi = dat_psi)
weights <-  rep(1, length(inc))
stan_est <- FitMDCEV(stan.dat,
model = model,
n_classes = n_classes,
fixed_scale = fixed_scale,
trunc_data = trunc_data,
seed = 123,
algorithm = "MLE",
n_iterations = n_iterations, n_chains = n_chains,
hb_random_parameters = hb_random_parameters,
print_ll = 0,
hessian = TRUE,
n_draws = n_draws,
keep_loglik = 0)
# MDCEV Model with fixed parameters estimated using MLE or Stan
# Load Packages ------------------------------------#
rm(list=ls(all=TRUE))
ls()
library(pacman)
p_load(tidyverse, rstan, rmdcev)
#---------------------------------------------------------------------------------------
# user input
nobs <- 1000 # number of individuals
inc <- 100000 + runif(nobs, 0, 50000) # budget
ngoods <- 10 # number of goods
price <- 5 + matrix(runif(nobs*ngoods, 0, 100), nobs, ngoods)  # price of non-numeraire good
model <- "gamma0"
beta <- c(-5, 0.5, 2, -1.5, 3, -2, 1, 2)
gamma <- 1 + runif(ngoods, 0, 2)
scale <- 1
fixed_scale <- 0
if (model == "les"){
model_num <- 1
alpha <- c(0.8, rep(0, ngoods))
parms_true <- c(beta, gamma, alpha[1], scale)
} else if (model == "alpha"){
model_num <- 2
alpha <- rep(0.7,ngoods+1)#0 + runif(ngoods+1, 0.01, .98)
gamma <- rep(1, ngoods)
parms_true <- c(beta, alpha, scale)
} else if (model == "gamma"){
model_num <- 3
alpha <- rep(0.5, ngoods+1)
parms_true <- c(beta, gamma, alpha[1], scale)
} else if (model == "gamma0"){
model_num <- 4
alpha <- rep(0, ngoods+1)
parms_true <- c(beta, gamma, scale)
} else
stop("No model specificied. Choose a model")
parms_true <- tbl_df(parms_true) %>%
rename(parms_true = value)
# Create psi variables that vary over alternatives
b1 <- rep(1,ngoods)
b2 <- rbinom(ngoods, 1, 0.5)
b3 <- runif(ngoods, 0, 1)
psi_j_temp <- list(b1 = b1,
b2 = b2,
b3 = b3)
# Create psi variables that vary by person
psi_socio = 2*matrix(runif(nobs * (length(beta)-3)), nobs,length(beta)-3)
psi_i_temp <- list(b4 = psi_socio[,1],
b5 = psi_socio[,2],
b5 = psi_socio[,3],
b5 = psi_socio[,4],
b5 = psi_socio[,5])
# Create full set of base psi variables
psi_j_temp <- map(psi_j_temp, function(x) {rep(x, each=nobs)})
psi_i_temp <- map(psi_i_temp, function(x) {rep(x, times= ngoods)})
dat_psi = c(psi_j_temp, psi_i_temp)
dat_psi = matrix(unlist(dat_psi), ncol = length(beta))
psi_sims <- matrix(dat_psi %*% beta, ncol = ngoods, byrow = TRUE)
psi_sims <- CreateListsRow(psi_sims)
psi_sims <- list(psi_sims )
names(psi_sims) <- "psi_sims"
inc_list <- list(as.list(inc))
names(inc_list) <- "inc" # price normalized MU at zero
price_list <- cbind(1, price) #add numeraire price to price matrix (<-1)
price_list <- list(CreateListsRow(price_list))
names(price_list) <- "price" # price normalized MU at zero
###########################################################################
# Pull individual level data into one list
###########################################################################
df_temp <- c(inc_list, price_list, psi_sims)
expose_stan_functions(stanmodels$SimulationFunctions)
quant <- pmap(df_temp, CalcmdemandOne_rng,
gamma_sim=gamma,
alpha_sim=alpha,
scale_sim=scale,
nerrs=nerrs,algo_gen = algo_gen)
expose_stan_functions(rmdcev:::stanmodels$SimulationFunctions)
quant <- pmap(df_temp, CalcmdemandOne_rng,
gamma_sim=gamma,
alpha_sim=alpha,
scale_sim=scale,
nerrs=nerrs,algo_gen = algo_gen)
#---------------------------------------------------------------------------------------
# user input
nobs <- 1000 # number of individuals
inc <- 100000 + runif(nobs, 0, 50000) # budget
ngoods <- 10 # number of goods
price <- 5 + matrix(runif(nobs*ngoods, 0, 100), nobs, ngoods)  # price of non-numeraire good
model <- "gamma0"
beta <- c(-5, 0.5, 2, -1.5, 3, -2, 1, 2)
nerrs <- 30
gamma <- 1 + runif(ngoods, 0, 2)
scale <- 1
fixed_scale <- 0
if (model == "les"){
model_num <- 1
alpha <- c(0.8, rep(0, ngoods))
parms_true <- c(beta, gamma, alpha[1], scale)
} else if (model == "alpha"){
model_num <- 2
alpha <- rep(0.7,ngoods+1)#0 + runif(ngoods+1, 0.01, .98)
gamma <- rep(1, ngoods)
parms_true <- c(beta, alpha, scale)
} else if (model == "gamma"){
model_num <- 3
alpha <- rep(0.5, ngoods+1)
parms_true <- c(beta, gamma, alpha[1], scale)
} else if (model == "gamma0"){
model_num <- 4
alpha <- rep(0, ngoods+1)
parms_true <- c(beta, gamma, scale)
} else
stop("No model specificied. Choose a model")
parms_true <- tbl_df(parms_true) %>%
rename(parms_true = value)
# Create psi variables that vary over alternatives
b1 <- rep(1,ngoods)
b2 <- rbinom(ngoods, 1, 0.5)
b3 <- runif(ngoods, 0, 1)
psi_j_temp <- list(b1 = b1,
b2 = b2,
b3 = b3)
# Create psi variables that vary by person
psi_socio = 2*matrix(runif(nobs * (length(beta)-3)), nobs,length(beta)-3)
psi_i_temp <- list(b4 = psi_socio[,1],
b5 = psi_socio[,2],
b5 = psi_socio[,3],
b5 = psi_socio[,4],
b5 = psi_socio[,5])
# Create full set of base psi variables
psi_j_temp <- map(psi_j_temp, function(x) {rep(x, each=nobs)})
psi_i_temp <- map(psi_i_temp, function(x) {rep(x, times= ngoods)})
dat_psi = c(psi_j_temp, psi_i_temp)
dat_psi = matrix(unlist(dat_psi), ncol = length(beta))
psi_sims <- matrix(dat_psi %*% beta, ncol = ngoods, byrow = TRUE)
psi_sims <- CreateListsRow(psi_sims)
psi_sims <- list(psi_sims )
names(psi_sims) <- "psi_sims"
inc_list <- list(as.list(inc))
names(inc_list) <- "inc" # price normalized MU at zero
price_list <- cbind(1, price) #add numeraire price to price matrix (<-1)
price_list <- list(CreateListsRow(price_list))
names(price_list) <- "price" # price normalized MU at zero
###########################################################################
# Pull individual level data into one list
###########################################################################
df_temp <- c(inc_list, price_list, psi_sims)
expose_stan_functions(rmdcev:::stanmodels$SimulationFunctions)
quant <- pmap(df_temp, CalcmdemandOne_rng,
gamma_sim=gamma,
alpha_sim=alpha,
scale_sim=scale,
nerrs=nerrs,algo_gen = algo_gen)
algo_gen <- 1
expose_stan_functions(rmdcev:::stanmodels$SimulationFunctions)
quant <- pmap(df_temp, CalcmdemandOne_rng,
gamma_sim=gamma,
alpha_sim=alpha,
scale_sim=scale,
nerrs=nerrs,algo_gen = algo_gen)
quant <- matrix(unlist(quant), nrow = nobs, byrow = TRUE)
quant <- quant[,2:(ncol(quant))]
stan.dat <- list(quant = quant,
price = price,
inc = as.vector(inc),
dat_psi = dat_psi)
stan_est <- FitMDCEV(stan.dat,
model = model,
n_classes = n_classes,
algorithm = "MLE",
hessian = TRUE,
n_draws = 30)
stan_est <- FitMDCEV(stan.dat,
model = model,
n_classes = 1,
algorithm = "MLE",
hessian = TRUE,
n_draws = 30)
stan_est <- FitMDCEV(stan.dat,
model = model,
n_classes = 1,
algorithm = "MLE",
hessian = TRUE,
n_draws = 30)
# MDCEV Model with fixed parameters estimated using MLE or Stan
# Load Packages ------------------------------------#
rm(list=ls(all=TRUE))
ls()
library(pacman)
p_load(tidyverse, rstan, rmdcev)
#---------------------------------------------------------------------------------------
# user input
nobs <- 1000 # number of individuals
inc <- 100000 + runif(nobs, 0, 50000) # budget
ngoods <- 10 # number of goods
price <- 5 + matrix(runif(nobs*ngoods, 0, 100), nobs, ngoods)  # price of non-numeraire good
algo_gen <- 1
model <- "gamma0"
beta <- c(-5, 0.5, 2, -1.5, 3, -2, 1, 2)
nerrs <- 30
gamma <- 1 + runif(ngoods, 0, 2)
scale <- 1
fixed_scale <- 0
if (model == "les"){
model_num <- 1
alpha <- c(0.8, rep(0, ngoods))
parms_true <- c(beta, gamma, alpha[1], scale)
} else if (model == "alpha"){
model_num <- 2
alpha <- rep(0.7,ngoods+1)#0 + runif(ngoods+1, 0.01, .98)
gamma <- rep(1, ngoods)
parms_true <- c(beta, alpha, scale)
} else if (model == "gamma"){
model_num <- 3
alpha <- rep(0.5, ngoods+1)
parms_true <- c(beta, gamma, alpha[1], scale)
} else if (model == "gamma0"){
model_num <- 4
alpha <- rep(0, ngoods+1)
parms_true <- c(beta, gamma, scale)
} else
stop("No model specificied. Choose a model")
parms_true <- tbl_df(parms_true) %>%
rename(parms_true = value)
# Create psi variables that vary over alternatives
b1 <- rep(1,ngoods)
b2 <- rbinom(ngoods, 1, 0.5)
b3 <- runif(ngoods, 0, 1)
psi_j_temp <- list(b1 = b1,
b2 = b2,
b3 = b3)
# Create psi variables that vary by person
psi_socio = 2*matrix(runif(nobs * (length(beta)-3)), nobs,length(beta)-3)
psi_i_temp <- list(b4 = psi_socio[,1],
b5 = psi_socio[,2],
b5 = psi_socio[,3],
b5 = psi_socio[,4],
b5 = psi_socio[,5])
# Create full set of base psi variables
psi_j_temp <- map(psi_j_temp, function(x) {rep(x, each=nobs)})
psi_i_temp <- map(psi_i_temp, function(x) {rep(x, times= ngoods)})
dat_psi = c(psi_j_temp, psi_i_temp)
dat_psi = matrix(unlist(dat_psi), ncol = length(beta))
psi_sims <- matrix(dat_psi %*% beta, ncol = ngoods, byrow = TRUE)
psi_sims <- CreateListsRow(psi_sims)
psi_sims <- list(psi_sims )
names(psi_sims) <- "psi_sims"
inc_list <- list(as.list(inc))
names(inc_list) <- "inc" # price normalized MU at zero
price_list <- cbind(1, price) #add numeraire price to price matrix (<-1)
price_list <- list(CreateListsRow(price_list))
names(price_list) <- "price" # price normalized MU at zero
###########################################################################
# Pull individual level data into one list
###########################################################################
df_temp <- c(inc_list, price_list, psi_sims)
expose_stan_functions(rmdcev:::stanmodels$SimulationFunctions)
quant <- pmap(df_temp, CalcmdemandOne_rng,
gamma_sim=gamma,
alpha_sim=alpha,
scale_sim=scale,
nerrs=nerrs,algo_gen = algo_gen)
quant <- matrix(unlist(quant), nrow = nobs, byrow = TRUE)
quant <- quant[,2:(ncol(quant))]
stan.dat <- list(quant = quant,
price = price,
inc = as.vector(inc),
dat_psi = dat_psi)
stan_est <- FitMDCEV(stan.dat,
model = model,
n_classes = 1,
algorithm = "MLE",
hessian = TRUE,
n_draws = 30)
